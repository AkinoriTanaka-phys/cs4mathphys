# 1-1. ファイル周辺の操作コマンド

このノートでやること：

- Linux/Unix系のOSをいわゆる「黒い画面」で操作するために必要な以下の基礎事項
    - シェルとは何か 
    - ファイル構造の説明
    - その操作のコマンド

## シェルとは何か

Google Cloud Shell にアクセスすると、黒い画面が開かれます。ここで開かれているソフトウェアを **シェル** と言います。

### プロンプトとコマンド

黒い画面に表示されている情報をまずみてみましょう：

```bash
Welcome to Cloud Shell! Type "help" to get started.
To set your Cloud Platform project in this session use `gcloud config set project [PROJECT_ID]`.
You can view your projects by running `gcloud projects list`.
akinori_physics@cloudshell:~$ 
```

これの最初の3行は Google からのメッセージですので、4行目の
```bash
akinori_physics@cloudshell:~$ 
```
だけに注目してください。
- これに加えて、`▮` や `▯` というシンボルが書かれていると思います。この長方形のシンボルはシェルが入力を受け付けている状態を表します。
- `akinori_physics@cloudshell:~$ ` は **プロンプト**（コマンドプロンプト） と呼ばれる部分で、このシェルを動かしているユーザーの情報＋`$`マークが表示されます。
    > なお、プロンプトの表示は使っているシェルの種類や状況によって変わりますので注意してください。ただし、どの場合でも「システムがコマンドを受け付けている状態」を表すことには変わりありません。

シェルの使い方は以下です：
1. プロンプト以後に何らかの動作指令の **コマンド** を入力
2. enterを押してそのコマンドを実行する

ユーザーはプロンプトを通じてコマンドを打って、コンピュータを操作してゆくことになります。以下では、GitHubの**コピペ機能を使えるようにするためにプロンプトは省いて書きます**。

- 例：ヘルプを表示

    Google Cloud Shellで以下のように打つと、ユーザー向けの最初のメッセージが出ます。
    ```bash
    help
    ```
    > ```
    > 
    > Welcome to Google Cloud Shell, a tool for managing resources hosted on Google Cloud Platform!
    > ...
    > ```
- 例：文字列を表示

    同じ画面にテキストを表示させるコマンド
    ```bash
    echo 1
    ```
    > ```
    > 1
    > ```
- 例：現在いる場所のファイルを表示

    ```bash
    ls
    ```
    > ```
    > README-cloudshell.txt
    > ```
    最初はこのファイルしかないため、一つしか出ないです。

- コメント
    `#` をつけると、その行のそれ以後の部分はプログラムとして認識されず無視されます。
    - ただしこれはシェルの設定によります。例えば、macOSは最近では `zsh` というシェルを採用していますが、こちらではデフォルトで対話的なシェル中でのコメント機能がオフになっているようです：
    - 参考：https://unix.stackexchange.com/questions/557486/allowing-comments-in-interactive-zsh-commands?utm_source=chatgpt.com

> [!NOTE]
> "シェル(shell)" は「殻」という意味ですが、なぜそのように呼ぶのかというと、例えば以下の文献
> - https://flex.phys.tohoku.ac.jp/texi/sh/node2.html
>
> で説明しているように、コンピュータの核（**カーネル**と呼びます）とユーザーの間の仲立ちをする＝カーネルを包む殻、というイメージからそのように呼ばれるようになったとのことです。

## ファイル構造の説明

### ファイルツリーと絶対パス

Unix系のOSは **ファイル(file)** と その入れ物である **ディレクトリ(directory)** から構成されるツリー構造を持ちます。例えば以下のようなイメージです：
> windowsではディレクトリはフォルダと呼ばれるものに対応します。

```
/
├── ファイルA
├── ファイルB
├── ディレクトリA
│   ├── ファイルC
│   ├── ファイルD
│   └── ディレクトリA2
│       ├── ファイルF
│       └── ファイルG
└── ディレクトリB
    ├── ファイルH
    └── ファイルI
```
ツリーの下部は上部の箱（ディレクトリ）に格納されているイメージです。一番上部のディレクトリ `/` を **ルートディレクトリ(root)** と言います。
> 実際のUnix系OSやLinuxのルート直下のファイル構成はもっと複雑で、システムに必要なさまざまなディレクトリとファイルが置いてあります。

また、このツリー上のファイルの「住所」を**絶対パス (absolute path)** と言います。絶対パスは
- `/ディレクトリA/ディレクトリA2/ファイルF`

のように、ルートディレクトリから始めて、ディレクトリ名の後に `/` を加えた文字列を使います。（ルートディレクトリだけは `/` のまま）
- 例：
    - ファイルAの絶対パス
        ```
        /ファイルA
        ```
    - ディレクトリAの絶対パス
        ディレクトリ自身の絶対パスを示す場合は最後に `/` はつけません
        ```
        /ディレクトリA
        ```
    - ファイルHの絶対パス
        ```
        /ディレクトリB/ファイルH
        ```

### カレントディレクトリと相対パス

シェルを起動すると、ユーザー（あなた）はある決まったディレクトリ上に「配置」されます。ここで、まず最初の重要なコマンドを説明します。

#### `pwd`: 自分が今どこにいるか
自分が現在いるディレクトリ（**カレントディレクトリ**といいます）を表示するコマンドです。
```bash
pwd
```
- 例：Google Cloud Shellにログインした直後
    ```bash
    pwd
    ```
    > ```
    > /home/akinori_physics
    > ```
    表示はGoogleアカウント名になるかと思います。

#### `touch`: 新たにファイルを作る

以下のコマンドで空のファイルを作成できます
> 正確にはこのコマンドは空ファイルを作るためのものではなく、名前の通りファイルにタッチする（更新履歴がついたりする）もので、タッチする対象ファイルが存在しない場合は新たに作る、というものです。

```bash
touch ファイル名
```

#### `mkdir`: 新たにディレクトリを作る

以下のコマンド（**m**a**k**e a **dir**ectory）で空のディレクトリを作成できます

```bash
mkdir ディレクトリ名
```
注意ですが、ディレクトリ名の後に `/` は不要です。

#### `ls`: 今いるディレクトリの中身を表示する

カレントディレクトリの中身をリスト（**l**i**s**t）で表示します

```bash
ls 
```
> オプションとして、`ls ディレクトリ名` という使い方もあり、この場合は `ディレクトリ名` で指定されたディレクトリの中身を表示します。指定の仕方は絶対パスか、後述する相対パスでも良いです。

#### `cd`: 移動する

以下のコマンドで自分のいる場所（カレントディレクトリ）を移動（**c**hange **d**irectory）することができます：
```bash
cd 移動先のディレクトリのパス
```
いくつか注意：
- 移動すると、プロンプトの表示が変わります。よくあるプロンプトは、**ユーザー名@マシン名:カレントディレクトリ** です。
- `cd` だけでも使え、その場合はホームディレクトリに戻ります。地味によく使う機能かもしれません。なお、`~` はホームディレクトリの略記パスです。
- ディレクトリを指定するためのパスは後述の相対パスでもOKです。

$\blacksquare$ **練習問題1:** 新たにファイル `test.txt` と、ディレクトリ `dtest` を作成し、`ls` で表示させてください。
> [!TIP]
> <details>
> <summary>解答例</summary>
> 
> ```bash
> touch test.txt # ファイル test.txt を作成
> mkdir dtest    # ディレクトリ dtest を作成
> ls             # 今いるディレクトリのファイルを確認
> ```
> > ```
> > dtest  README-cloudshell.txt  test.txt
> > ```
> なお、Google Cloud Shellではディレクトリは青色で表示されるようです。
> </details>

$\blacksquare$ **練習問題2:** 練習問題1で作成した ディレクトリ `dtest` に移動し、`pwd` して確かにカレントディレクトリが変わっていることを確認してください。また、`ls` してファイルがないことを確認してください。
> [!TIP]
> <details>
> <summary>解答例</summary>
> 
> 絶対パスで指定してもいいですが、次のセクションで説明している相対パスで指定するほうが普通かなと思います（フライングですいません）
>```bash
>cd dtest  # ディレクトリ /home/akinori_physics/dtest に移動
>pwd       # 今いるディレクトリの絶対パスを表示
>```
>> ```
>> /home/akinori_physics/dtest
>> ```
>```bash
> ls       # 今いるディレクトリのファイルを表示
> ```
> 何も出ないはず。
> </details>

#### カレントディレクトリと相対パス

カレントディレクトリ自身を表すファイル名と、その親を表す（隠し）ファイル名があります：
- カレントディレクトリ： `.`
- 一つ上のディレクトリ： `..`

3つ点 `...` というのは**ない**です。親の親は `../..` のように表現します。

また、カレントディレクトリ直下のファイルやディレクトリは、絶対パスで指定しなくても、ファイル名やディレクトリ名だけで参照できます。これは **相対パス (relative path)** と呼ばれます。例えばファイル構成とカレントディレクトリが以下のような場合：
```
/
├── ファイルA
├── ファイルB
├── ディレクトリA      <- カレントディレクトリ
│   ├── ファイルC
│   ├── ファイルD
│   └── ディレクトリA2
│       ├── ファイルF
│       └── ファイルG
└── ディレクトリB
    ├── ファイルH
    └── ファイルI
```
- `ファイルC` の相対パス：
    ```
    ファイルC
    ```
- `ディレクトリA2` の相対パス：
    ```
    ディレクトリA2
    ```
- `ファイルA` の相対パス：
    ```
    ../ファイルA
    ```
- `ファイルH` の相対パス：
    ```
    ../ディレクトリB/ファイルH
    ```

シェルのコマンドにパスを渡す際には、
- `/` から始まる＝絶対パス
- `/` 以外から始まる＝相対パス

とみなされます。絶対パスは作業しているうちに覚えられなくなるため、シェルでは
1. `cd` でカレントディレクトリを変える（移動する）
2. 相対パスでファイル名やディレクトリ名を指定してコマンド実行

することが多いかなと思います。（`pwd` で自分のいる絶対パスはいつでも確認できますが、確認するより相対パスを使ったほうが早いです。）


$\blacksquare$ **練習問題3:** まず以下のコマンドで練習問題用のディレクトリを構成します：
```bash
cd ~             # ホームディレクトリに戻る
mkdir exercise3  # 練習問題用のディレクトリを作成
```
こののち、`exercise3` 以下に下のようなファイルツリーを作ってください：
```
exercise3
├── test.txt
├── test1
│   └── test1.txt
└── test2
    └── test2.txt
```
この状態で、
1. カレントディレクトリを `test2` に移して
2. `ls test1の相対パス` を叩いて、`test1`の中身が表示されるようにしてください。

> [!TIP]
> <details>
> <summary>解答例</summary>
> 
>ファイルツリーの作り方：`touch`でファイルを作るためには `test1` や `test2` に一度入らないといけないですが、そこから抜けるために `cd ..`（一つ上のディレクトリに戻る、よく使うコマンドです）が使えます。
>```bash
>cd exercise3     # 練習問題用に作ったディレクトリに入る
>touch test.txt   # ファイル test.txt を作成
>mkdir test1      # ディレクトリ test1 を作成 
>mkdir test2      # ディレクトリ test2 を作成 
>cd test1         # ディレクトリ test1 に入る
>touch test1.txt  # ファイル test1.txt を作成
>cd ..            # 一つ上のディレクトリに戻る
>cd test2         # ディレクトリ test2 に入る
>touch test2.txt  # ファイル test2.txt を作成
>```
>この最終段階でカレントディレクトリは `test2` なはずです：
>```bash
>pwd              # カレントディレクトリの絶対パスを表示する
>```
>> ```
>> /home/akinori_physics/exercise3/test2
>> ```
>ここから `test1` への相対パスで中身を見るには
>```bash
>ls ../test1
>```
>> ```
>> test1.txt
>> ```
>となります。
> </details>

### ファイルへの書き込み

ここまで、ファイルは空ファイルしか使って来ませんでしたが、それだけではつまらないですし、意味がありません。**ファイルには文字列が書き込まれます。** それ以上でもそれ以下でもありません。文字列が書き込まれたファイルは、手元のmacOSやwindowsでは手頃なテキスト編集ソフト（**テキストエディタ**といいます）があって、それを使って作成できますがシェル（黒い画面）のみで作成することが可能です。

#### シェル外部のテキストエディタを使う

Google Cloud Shell を使っている場合、実は手元のPCでやるような、シェルではない別のソフトウェアを用いた通常のテキストファイル編集が可能です。

1. 編集したいファイルを（`touch`で）作成しておく（ここは必須ではないです）
2. 右上のペンのアイコンをクリック
3. 左側にファイルツリーが出るので、編集したいファイルをクリック
4. 右側に普通のテキストエディターが出るので、それで編集

とすると良いです。

#### シェルから使えるテキストエディタ `nano` を使う

Google Cloud Shell を使っていない場合、特にこの講義の後で説明する予定の `ssh` コマンドによる、インターネットを介したリモートサーバー上でのシェルを使っている場合は、クリックなどの直感的操作が可能なエディタを使うことは（特別な処理を行った場合を除き）できません。その際に手頃なのが、シェルから直接使えるエディタです。

有名どころは `vi(m)` と `emacs` ですが、これらは **コマンドを覚えていないと終了することすらできない** ことで悪名高い（？）ので、今回はそのような障壁が比較的低い `nano` というエディタを使ってみます。こちらは基本的なコマンドが下に常に表示してあるため、エディタ終了のコマンドを忘れたりしても安心です。

使い方は以下：
```bash
nano test.txt
```
としてエンターキーを打つと、次のような表示になると思います：
```
  GNU nano 7.2               test.txt  
▮





^G Help         ^O Write Out    ^W Where Is     ^K Cut          ^T Execute      ^C Location     M-U Undo        M-A Set Mark    M-] To Bracket  M-Q Previous    ^B Back
^X Exit         ^R Read File    ^\ Replace      ^U Paste        ^J Justify      ^/ Go To Line   M-E Redo        M-6 Copy        ^Q Where Was    M-W Next        ^F Forward
```

`▮` の部分がアイコンで、通常通り文字編集が可能です。下の部分に一覧で出ているのがファイル編集に関するコマンド（**`^` は \<control\>キー を表します**）ですが、とりあえずファイルの閉じ方 `Exit` のやり方（`^X` なので、\<control\>キー と\<X\>キーを押す）だけ押さえておきましょう。適当に編集してからファイルを閉じようとすると、`Save modified buffer?` と尋ねられるので、編集内容を保存する場合は `Y` と打ちます。

#### `cat`: ファイルの内容を表示する

con**cat**enate の略らしいです。作ったファイルの内容を「全て」シェル上に表示するコマンドです：
```bash
cat ファイルのパス
```
ファイルのパスは絶対パスでも相対パスでもOKです。
> 実用上は `nano` などのエディタでファイルの中身を見られるので、そこまで使うことはないかもしれません。

#### `head` と `tail`: ファイルの内容を表示する

`cat` ではファイル内容の「全て」を表示してしまうので沢山文字が書かれたファイルだと情報が見づらいことがあります。ファイルの始まり（頭）か終わり（尾）部分を複数行表示するのがこれらのコマンドです。
- 始まりの表示
    ```bash
    head ファイルのパス
    ```
- 終わりの表示
    ```bash
    tail ファイルのパス
    ```

$\blacksquare$ **練習問題4:** `nano` を使って、中身が空でない適当なテキストファイルを作ってください。
> [!TIP]
> <details open>
> <summary>解答例</summary>
> 
> `nano` の終わり方さえ押さえておけば簡単だと思うので略。
> </details>

$\blacksquare$ **練習問題5:** 練習問題4 で作ったファイルの内容をシェル上に表示させてください。 
> [!TIP]
> <details>
> <summary>解答例</summary>
> 
>絶対パス `/home/akinori_physics/test` に以下の内容を書き込みました：
>```
># comment
>This is a test.
>If this sentense is shown, the test is success.
>Thank you.
>
>```
>これを表示させてみると：
>```bash
>cat /home/akinori_physics/test
>```
>> ```
>> # comment
>> This is a test.
>> If this sentense is shown, the test is success.
>> Thank you.
>> ```
> もちろん、絶対パスではなく相対パスで表示させても良いです。（私自身は、そっちの方が普段使いに近いです。）
> </details>

### ファイルツリー操作のコマンド

ファイルツリーは一度作成した後、ファイルやディレクトリを削除したり、名前を変えたり場所を変えたりできます。

#### `rm`: ファイルを削除する

コマンド名は **r**e**m**ove の略だと思います。

```bash
rm 消去したいファイルのパス
```

> [!WARNING]
> 普通のPCのゴミ箱昨日とは異なり、**このコマンドで消したファイルは原則、二度と元に戻せません。**

#### `rmdir`: ディレクトリを削除する

中が空でないと削除不可能です。

```bash
rmdir 消去したいディレクトリのパス
```

> [!NOTE]
> このコマンドで消したファイルが原則元に戻せないのは `rm` と同じですが、こちらは中が空でないとエラーが出て消せない分、少し安全です。しかし普段使いでは「ディレクトリの中身ごと丸々削除したい」ことは多々あります。このことはもちろん可能ですが、説明は次回（の演習問題）に回します。

#### `mv`: ファイルの名前か場所を変える

コマンド名はおそらく、**m**o**v**e の略かと思います。
```bash
mv 元ファイルのパス 変更後のファイルのパス
```
パス→パスの変更なので、場所/名前の変更の両方に使えます。

#### `cp`: ファイルをコピーする

**c**o**p**y の略でしょう：
```bash
cp 元ファイルのパス コピー先のファイルのパス
```

$\blacksquare$ **練習問題6:** 適当なファイル "test.txt" を作成したのち
1. "copied.txt" という名前のコピーファイルを作成
2. "test.txt" → "renamed.txt" に名前変更
3. "copied.txt" を削除

をしてください。
> [!TIP]
> <details>
> <summary>解答例</summary>
> 
> "test.txt" を作成します。今回はホームディレクトリに作ることにします：
> ```bash
> cd ~
> nano test.txt
> ```
> >```
> >  GNU nano 7.2                        test.txt                                  
> >This is test.
> >
> >                                  [ New File ]
> >^G Help      ^O Write Out ^W Where Is  ^K Cut       ^T Execute   ^C Location
> >^X Exit      ^R Read File ^\ Replace   ^U Paste     ^J Justify   ^/ Go To Line
> >```
> ```bash
> cat test.txt
> ```
> > ```
> > This is test.
> > ```
> - 1."copied.txt" という名前のコピーファイルを作成
> ```bash
> cp test.txt copied.txt
> ls 
> ```
> > ```
> > copied.txt  README-cloudshell.txt  test.txt
> > ```
> できていそうです。中身を見てみます：
> ```bash
> cat copied.txt
> ```
> > ```
> > This is test.
> > ```
> - 2."test.txt" → "renamed.txt" に名前変更
> ```bash
> mv test.txt renamed.txt
> ls 
> ```
> > ```
> > copied.txt  README-cloudshell.txt  renamed.txt
> > ```
> "test.txt" の名前が変わったのがわかります。
> - 3."copied.txt" を削除
> ```bash
> rm copied.txt
> ls
> ```
> > ```
> > README-cloudshell.txt  renamed.txt
> > ```
> きちんと消えています。
> 
> </details>

$\blacksquare$ **練習問題7:** 以下のコマンドを動かしてディレクトリを作ります：
```bash
mkdir dtest
cd dtest
touch test.txt
cd ..
```
この状態から ディレクトリ "dtest" を削除してください。
> [!TIP]
> <details>
> <summary>解答例</summary>
> 
>ディレクトリの削除には `rmdir` を使うのでした。やってみると：
>```bash
>rmdir dtest
>```
>> ```
>> rmdir: failed to remove 'dtest': Directory not empty
>> ```
>ディレクトリが空じゃないから消すのに失敗した、と出ますので、中身を消しましょう。まず中にどんなファイルがあるか確認します：
>```bash
>cd dtest
>ls
>```
>> ```
>> test.txt
>> ```
>一つしかファイルがないので、これを消せば良いでしょう。
>```bash
>rm test.txt
>```
>その後、一つ上のディレクトリに移動して `rmdir dtest` とすれば良いです：
>```bash
>cd ..
>rmdir dtest
>```
>`ls` すれば消えていることが確認できるはずです。
> </details>

## シェルを使う上で便利なこと色々

シェルにはいくつか標準装備の便利機能があります。

### \<Tab\> による 自動補完機能

コマンド途中で \<Tab\> キー を押すと、自動で補完してくれます。複数の補完可能性がある場合は、その一覧が出るので続けて文字を入れないといけません。

これはコマンド名だけではなく、ファイル名などにも適用されるルールで便利です。
- 例：
    例えば以下のような状況の時：
    ```bash
    touch test_january.txt test_february.txt test_march.txt
    ls 
    ```
    > ```
    > test_february.txt  test_january.txt  test_march.txt
    > ```
    `test_march.txt` の中身（空ですが）を見たい場合、以下の部分まで書いて、\<Tab\>を押すと
    ```bash
    cat test_m#ここで<Tab>を押す
    ```
    $`\downarrow`$ 
    ```bash
    cat test_march.txt 
    ```

なお、タイピングを減らせるだけでなくタイプミスによるバグの可能性も無くなるので、積極的に使っていくと良いかと思います。

### コマンド履歴

シェルでは \<↑\>キーと \<↓\>キーでこれまで実行したコマンド履歴を遡ることができます。
- 例

    わかりやすさのために意味のないコマンドを実行します：
    ```
    test1
    ```
    > ```
    > -bash: test1: command not found
    > ```
    ```
    test2
    ```
    > ```
    > -bash: test2: command not found
    > ```
    この後のプロンプトで \<↑\>キー を押すと：
    ```bash
    # <↑>キー を押す
    ```
    $`\downarrow`$
    ```bash
    test2
    ```
    何度も押すともっと遡れますし、\<↓\> キーで新しい方にも戻れます。   



#### 履歴の検索

さらに、いつ実行したかわからないけど、履歴の中から、実行したコマンドの中の文字列を検索したい場合は 
- 検索開始：\<control\>キー ＋ \<R\>キー
    ```bash
    (reverse-i-search)`': ▮
    ```
    という新たなプロンプトが出て、文字列を入力できるようになります。
    - ここに文字列を入力するとオンタイムで該当するコマンドが出てきます。
    - 文字列入力は delete で一文字消せます。
        - 検索終了方法：
            1. 検索で該当したコマンドが表示されている状態（例）：
                ```bash
                (reverse-i-search)`ta': tail README-cloudshell.txt
                ```
                でenterを押して、該当コマンド（この例だと `tail README-cloudshell.txt`）を実行する
            2. \<control\>キー ＋ \<G\>キー を押す
                - 例えば「検索したコマンドの一部を変更して実行したい場合」などは、検索結果をコピペしたのち、このキーを押すと良いです。
        - 検索モード中に \<↑\>キー \<↓\>キー を押しても終了できるように見えますが、実は終了していないため振る舞いが変になっています（検索で最後にヒットしたコマンドから上がったり下がったりになる）。この状態は適当なコマンドを実行すると元に戻るのでそんなに問題はないようですが。 

### ワイルドカード

シェルでは特殊な文字が登録されており、その文字を使うと単なる文字以上の意味合いを持つことがあります。
- `*`: 0文字以上の任意の文字列にマッチ

    以下の状況だとします：
    ```bash
    ls
    ```
    > ```
    > fuga.txt        hoge.txt        hoge2.txt       hogehoge.txt
    > ```
    この状態で例えば
    ```bash
    rm hoge*
    ```
    とすると、"hoge"で始まるファイルを一度に消すことができます：
    ```bash
    ls
    ```
    > ```
    > fuga.txt
    > ```
- `?`: 任意の1文字にマッチ	

    以下の状況だとします：
    ```bash
    ls
    ```
    > ```
    > fuga.txt        hoge1.txt       hoge2.txt       hogehoge.txt
    > ```
    この状態で例えば
    ```bash
    rm hoge?.txt
    ```
    とすると、"hoge1" と "hoge2" だけを一度に消すことができます：
    ```bash
    ls
    ```
    > ```
    > fuga.txt        hogehoge.txt
    > ```

他にもいくつかあるので調べておくと良いです。これらの特殊文字は、一応 `\` をつける（例えば `\*`）と通常の文字扱いにすることはできますが、思わぬ事故の原因になるため**ファイル名には用いない**ようにしてください。同様の理由で `/` もディレクトリ名の分割と勘違いされるため、ファイル名には入れない方がいいです。

### コマンドの使い方を調べる

これまでに紹介したいくつかのコマンドは **オプション引数** などをつけることができ、そのすべての機能を紹介したわけではありません。コマンド名を知っている場合、そのコマンドの詳細な説明を表示するコマンドがあり、以下のどちらかで使えると思います：
1. `help` コマンド
    ```bash
    help コマンド名
    ```
    - Google Cloud Shellでは `help` は Google Cloud Shell のヘルプが出てしまうのですが、代わりに
        ```bash
        builtin help コマンド名
        ```
        とすると良いです。
2. `man` コマンド（**man**ual）
    ```bash
    man コマンド名
    ```
    こちらは閉じる際に `q` （**q**uit）をタイプします。
    - Google Cloud Shellでは使えないようです。

両者の違いは気になった人は調べてみてください。使う分にはどちらかでヒットするか調べてみて、説明が出ればそれを読む、といった感じでとりあえずは十分かと思います。

あるいはネットで検索するのもOKです。
> LLMに尋ねても概ね正しい答えが得られるとは思いますが、必ず情報源を確認するようにした方が良いです。

### コマンドが存在するか調べる

コマンドが存在し、システムが認識している場合
```bash
which コマンド名
```
を実行して、表示が出ればそのコマンドが使えることを意味します。この周辺についてはまた後のセクションで説明します。


$\blacksquare$ **練習問題8:** 以下のコマンド（そのままコピペでOK）で練習問題用の環境を作ります：
```bash
cd ~                              # ホームに戻る
mkdir exercise8                   # 練習問題用のディレクトリを作成
cd exercise8                      # そこに入る
touch test.txt hoge.txt fuga.txt  # 適当なファイルを複数作成
mkdir test_dir                    # 適当なディレクトリを作成
```
こののち、
1. `cat f` まで入力して\<tab\>キーを押して何が出てくるかみてください
2. `cat t` まで入力して\<tab\>キーを押して何が出てくるかみてください
    - 表示が出たら、さらに続けて2回 \<tab\>キーを押して何が出てくるかみてください
> [!TIP]
> <details>
> <summary>解答例</summary>
> 
> 1 は
> ```bash
> cat fuga.txt
> ```
> が出るはずです。2は1回目で `test` まで、3回目で
> ```
> test_dir/ test.txt
> ```
> の二つが出ます。
> </details>

$\blacksquare$ **練習問題9:** 以下のコマンドを打つと、これまでに打ってきたコマンドの履歴を表示できます：
```bash
history | tail
```
\<↑\>キーと \<↓\>キーでこの履歴を辿れることを確認してください。また、\<control\>キー ＋ \<R\>キーで検索してみてください。
> [!TIP]
> <details open>
> <summary>解答例</summary>
> 
> 省略
> </details>

$\blacksquare$ **練習問題10:** 以下のコマンド（そのままコピペでOK）で練習問題用の環境を作ります：
```bash
cd ~              # ホームに戻る
mkdir exercise10  # 練習問題用のディレクトリを作成
cd exercise10     # それに入る
mkdir tests       # ディレクトリを作成
# 沢山のファイルを作成
touch test1.txt test2.txt test3.txt test4.txt test5.txt test6.txt test7.txt test8.txt test9.txt test10.txt
```
この状態で `ls` すると、
- "tests" というディレクトリ
- "test1.txt"から"test10.txt" のファイル

が存在していることがわかります。"test1"から"test10" のファイルを全て "tests" に入れてください。ヒント：実は移動先のパスをディレクトリ名だけで指定すると `mv` はその中にファイルを入れる、という意味になります。
> [!TIP]
> <details>
> <summary>解答例</summary>
> 
> ```bash
> mv test*.txt tests
> ```
> これでOK。確認してみる：
> ```bash
> ls tests
> ```
> > ```
> > test10.txt  test1.txt  test2.txt  test3.txt  test4.txt  test5.txt  test6.txt  test7.txt  test8.txt  test9.txt
> > ```
> 
> </details>

## コラム1: 枯れた技術

数物系の中にはプログラミング技術について以下のように考えている人がいるかもしれません：

1. キャッチアップしてもまた新たなものが出てくるため、勉強したことがすぐに使えなくなる可能性が高い。
2. 時間がもったいないので、そんなものをわざわざ勉強する価値はない。

開発が活発に進んでいる技術の場合、この指摘はある程度正しいと思います。しかしながら、Unix/Linuxに関してはこの限りではないのです。理由は：
- [システムが完成していること]
    - Linuxの開発は現在でも進んでいるが、基本となるシステムは完成しており、現在の開発のメインはメンテナンスである
- [みんなに信頼され浸透していること]
    - 広くその有用性が認識されており、Unix/Linux周りのインフラが充実している

が挙げられます。つまり、**これからも同じものが使い続けられる可能性が極めて高い**のです。このような状態を（良い意味で）**枯れている** と表現することがあります。
- https://ja.wikipedia.org/wiki/%E6%9E%AF%E3%82%8C%E3%81%9F%E6%8A%80%E8%A1%93

似た状況の技術に「数式を書く技術」であるLaTeXが挙げられます。LaTeXも基本となる部分はこれから大きな変更があるとは考えづらく、数理分野では広く浸透しているため、LaTeXを勉強するのは時間の無駄と考えている人は少数派でしょう。Unix/Linuxは「コンピュータの使い方の技術」として、これと同じような状況にあります。
