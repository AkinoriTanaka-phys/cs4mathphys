# 1-2. コマンドを組み合わせる方法

このノートでやること：

- コマンドの力を増幅させるテクニック
    - コマンドの引数、オプション
    - 標準入出力
    - コマンドを組み合わせる：パイプ、リダイレクト

## コマンドの合成の基礎

### 1コマンドの形式

前回いくつかのシェルのコマンドを紹介しましたが、その形式は全て以下のようなルールに基づいています。

```bash
コマンド名 [オプション] [コマンド引数]
```
それぞれの区切りには半角スペースを用います。
- `[オプション]`（複数同時に設定することも可能）
    - ハイフン1つ`-`で指定するタイプ
        - 例：
            ```bash
            ls -a # 隠しファイルも表示する
            ```
            > ```
            > 隠しファイル(.で始まるファイル名)も含め全てのファイルが表示される
            > ```
    - ハイフン2つ`--`で指定するタイプ
        - 例：
            ```bash
            ls --help # コマンドのヘルプ文を表示する
            ```
            > ```
            > ヘルプ文が表示されます。
            > ```
- `[コマンド引数]`
    - 前回の例で言うと：
        - `touch ファイル名` の `ファイル名`
    - 複数あっても良い。前回の例で言うと：
        - `touch ファイル名1 ファイル名2`

イメージ図をかくと以下のような感じです：

<img src="figs/command.drawio.svg" width=50%>

$\blacksquare$ **練習問題1:** `ls` コマンドのオプションで `-l` というものがあります。ホームディレクトリでこれを実行してみてください。
> [!TIP]
> <details>
> <summary>解答例</summary>
> 
>```bash
>cd # cd だけだとホームに戻ります
>ls -l
>```
>> ```
>>total 8
>>drwxrwxr-x 2 akinori_physics akinori_physics 4096 Apr 14 16:47 dtest
>>-rwxr-xr-x 1 akinori_physics akinori_physics  913 Apr 18 14:46 README-cloudshell.txt
>> ```
>表示の意味は以下です：
>- 最初に `total x` と数が表示される（ディスク上で何ブロック占めているかが `x` らしいです、今すぐ理解しなくて良いと思います）
>- ファイル/ディレクトリごとに改行があり、最初の行で言うと
>    1. `drwxrwxr-x` のような記号の列：これは `d` + `rwxrwxr-x` と読みます。冒頭の文字はファイルの種類（`d`はディレクトリ）、2つ目の文字列はファイルの権限（次回かその次に説明）を表します。
>    2. `2` リンク数という数字（今すぐ理解しなくて良いと思います）
>    3. `akinori_physics` 所有ユーザー（次回かその次に説明）
>    4. `akinori_physics` 所有グループ（次回かその次に説明）
>    5. `4096` ファイルサイズ（バイト単位）
>    6. `Apr 14 16:47` 最終更新日時
>    7. `dtest` ファイル名（これはディレクトリですが、ディレクトリを表すのも実体はその中身を指し示すファイルです）
> </details>

$\blacksquare$ **練習問題2:** 検索 `find` コマンドには `-name` というオプションがあり
```bash
find ディレクトリパス -name ファイル名
```
でそのディレクトリより下の階層でファイル名にマッチするファイルのパスを再帰的に探してくれます。そこで以下を実行してください：
```bash
cd ~; mkdir exercise1; cd exercise1 # ; は改行と同じで、コマンドを区切る意味になります
touch test.txt hoge.txt fuga.txt
for i in {1..5}; do mkdir dtest$i; done
for i in {1..5}; do if [ $i -gt 2 ]; then cd dtest$i; touch test.txt; cd ..; fi; done
cd ..
```
これで ディレクトリ "exercise1" のなかにいくつかのディレクトリとファイルが作られます。この状態から、ディレクトリ "exercise1" の中の "test.txt" という名前のファイルを全て探し出してください。
> [!TIP]
> <details>
> <summary>解答例</summary>
> 
>```bash
>find exercise1 -name test.txt
>```
>> ```
>> exercise1/test.txt
>> exercise1/dtest5/test.txt
>> exercise1/dtest3/test.txt
>> exercise1/dtest4/test.txt
>> ```
> </details>

$\blacksquare$ **練習問題3:** 前回、ディレクトリを消去する `rmdir` コマンドを紹介しましたが、中身までは消してくれませんでした。迂闊なミスを避けるという意味で、こちらを先に紹介しましたが、ファイル削除のコマンド `rm` のオプションで、ディレクトリの中身も含め全て消去できます：
```bash
rm -r ディレクトリのパス # 危険なコマンドなので、使う時は十分注意してください
```
中身のあるディレクトリを作って、これで丸ごと削除してみてください。
> [!TIP]
> <details>
> <summary>解答例</summary>
> 
>"exercise2" というディレクトリに "test.txt" というファイルが入った状態にします：
>```bash
>cd ~; mkdir exercise2; cd exercise2; touch test.txt; cd ..
>ls exercise2
>```
>> ```
>> test.txt
>> ```
>この状態で "exercise2" を消してみます：
>```bash
>rm -r exercise2
>```
>これで消えているはずです。
>
> </details>



### 標準入出力

上の説明は実はまだ不完全で、コマンド実行の構造にはこれにもう少しつけ加わります。

<img src="figs/stdio.drawio.svg" width=50%>

それぞれ：
- 標準入力（`stdin`: standard input の略）
    - コマンドが受け取る特別な入力の文字列のこと（**`[コマンド引数]`とは違う**）（何も入力しなくていい場合は空文字）
- 標準出力（`stdout`: standard output の略）
    - コマンドが正常に完了した際の出力で、通常はコマンド実行後にシェル上に文字列で表示される（何も出ない場合は空文字）
- 標準エラー出力（`stderr`: standard error の略）
    - コマンドが異常に終了した際の出力で、通常はコマンド実行後にシェル上に文字列で表示される（何も出ない場合は空文字）

となります。この三つを合わせて **標準入出力** と言います。

- 例1:

    コマンドの結果がシェルに表示されるもの：
    ```bash
    ls 
    ```
    >```
    >README-cloudshell.txt
    >```
    これが標準出力です
- 例2: 

    存在しないコマンドを入力し実行したときのエラー文：
    ```bash
    hoge
    ```
    > ```
    > -bash: hoge: command not found
    > ```
    これが標準エラー出力です。
- 例3:

    引数にファイル名などを想定するコマンドで引数を抜かした場合：
    ```bash
    cat
    ```
    >```
    > # 何か文字を入力できるようになる
    > # <control> + <D> で終了
    >```
    この時に入力した文字列が標準入力です。（こうならないコマンドもあります）

コマンドの合成は標準入出力を介して行います。

## リダイレクト：コマンドとファイルを繋げる

コマンドのフローは 左 → 右 が基本と考えて良いと思います。

> [!NOTE]
> 一応、逆向きの
> ```bash
> コマンド < ファイルのパス
> ```
> という文法もあり、これはコマンドの標準入力＝ファイルの内容になるというものです。ですが私自身あまり使ったことがない（他で代用できる）ため、ここでは説明から省きます。もう一つ似た機能で **ヒアドキュメント**
> ```bash
> コマンド << 終了トークン
> 文字列1
> 文字列2
> ...
> 文字列N
> 終了トークン
> ```
> という記法があります。これは `文字列1` から `文字列N` まで改行込みの文字列として扱い、コマンドの標準入力に流すという処理です。こちらは次回のシェルスクリプトの説明で使います。

### コマンドの標準出力→ファイル書き込み

以下のように、標準出力をそのままシェルに表示せずに、ファイルに書き込むことができます。

<img src="figs/redirect1.drawio.svg" width=50%>


基本構文は以下です：
```bash
コマンド > ファイルのパス  # すでに存在する場合は上書き
コマンド >> ファイルのパス # すでに存在する場合は追記
```
- 例：
    `echo テキスト` は標準出力に `テキスト` を出力するコマンドです。これとリダイレクト `>` を使って、ファイルに文字を書き込むことができます：
    ```bash
    echo "This is test." > test.txt
    cat test.txt
    ```
    > ```
    > This is test.
    > ```
    追記 `>>` してみます：
    ```bash
    echo "I need more beer." >> test.txt
    cat test.txt
    ```
    > ```
    > This is test.
    > I need more beer.
    > ```
    すでに内容があるファイルを `>` で書き込むと新規上書きなので注意してください。たとえば上のコマンドに続いて以下を打つと、上書きされてしまいます：
    ```bash
    echo "same file but overwritten." > test.txt
    cat test.txt
    ```
    > ```
    > same file but overwritten.
    > ```


### コマンドの標準エラー出力→ファイル書き込み

なお、`>` によるリダイレクトでは 標準出力`stdout` だけが対象なので、エラーが起こった場合の出力は書き込めません。標準エラー出力 `stderr` の表示を書き込む場合は別の（似た）コマンドを使います。イメージ図は以下：

<img src="figs/redirect2.drawio.svg" width=50%>

やり方はリダイレクトの `>` や `>>` の前に `2` を加えるだけです。

```bash
コマンド 2> ファイルのパス # すでに存在する場合は上書き
コマンド 2>> ファイルのパス # すでに存在する場合は追記
```

> [!NOTE]
> なぜ `2` をつけるか疑問だと思います。Unix/Linux系統のシステムでは、背後でファイルを0から始まる整数でラベル付け（ファイルディスクリプタという）しており、
> - 0 は 標準入力 `stdin`
> - 1 は 標準出力 `stdout`
> - 2 は 標準エラー出力 `stderr`
> 
> が設定されており、`2>` という記法名はここから来ています。なお、同様に `0>` は標準入力のリダイレクト、`1>` は標準出力のリダイレクトを表しますが、あんまり使うことがないというだけでしょう。

- 例：

    存在しないコマンドを実行しようとするとエラーが起こります：
    ```bash
    hoge
    ```
    > ```
    > -bash: hoge: command not found
    > ```
    このエラー文を `>`（標準出力用のリダイレクト） でファイルに書き込もうとしてみると：
    ```bash
    hoge > test
    cat test
    ```
    > ```
    > ```
    何も書き込まれていないことがわかります。エラー出力を書き込むには `2>` です：
    ```bash
    hoge 2> test
    cat test
    ```
    > ```
    > -bash: hoge: command not found
    > ```

### コマンドの標準出力/標準エラー出力→ファイル書き込み

さて、ここまでの説明だと、標準出力か標準エラー出力かどちらかしかファイルに書き込めませんでした。実はこれらを同時にリダイレクトさせることができます：

<img src="figs/redirect3.drawio.svg" width=50%>

コマンドは以下のように、

```bash
コマンド > stdout用ファイルのパス 2> stderr用ファイルのパス # すでに存在する場合は上書き
```
いくつか注意：
- `>>` に換えると 追記モードであることに変わりはありません。
- `>` と `2>` の順はどちらでも良いです。

なお、両方を同じファイルに書き込む場合は以下のように `&` をつけます：

```bash
コマンド &> ファイルのパス # すでに存在する場合は上書き
コマンド &>> ファイルのパス # すでに存在する場合は追記
```

$\blacksquare$ **練習問題4:** ファイルの情報を標準出力に表示するコマンドに
```bash
stat ファイルパス
```
というのがあります。この出力結果を適当な別ファイルにリダイレクト `>` で書き込んで、中身を確認してみてください。中身の確認には `cat ファイルパス` や、 `nano ファイルパス` が使えます。

> [!TIP]
> <details>
> <summary>解答例</summary>
> 
>まず、適当なファイルで `stat` の振る舞いを見てみます：
>```bash
>cd
>stat README-cloudshell.txt
>```
>> ```
>>   File: README-cloudshell.txt
>>   Size: 913             Blocks: 8          IO Block: 4096   regular file
>> Device: 8,17    Inode: 131080      Links: 1
>> Access: (0755/-rwxr-xr-x)  Uid: ( 1000/akinori_physics)   Gid: ( 1000/akinori_physics)
>> Access: 2025-02-13 15:57:32.288154382 +0000
>> Modify: 2025-04-20 01:33:29.597602431 +0000
>> Change: 2025-04-20 01:33:29.597602431 +0000
>>  Birth: 2025-02-13 15:57:32.288154382 +0000
>> ```
>ファイルサイズや、いつ編集したかなどの情報が標準出力として出ていることが確認できます。例えばこれを "test.txt" に書き込むとします。ファイルに書き込んだことを明確にするため、ファイルには適当なヘッダーをつけるとします：
>```bash
>echo \#\#\# This is header. > test.txt
>stat README-cloudshell.txt >> test.txt # ファイルヘッダーを残したいので追記 >> を使う
>cat test.txt
>```
>> ```
>> ### This is header.
>>   File: README-cloudshell.txt
>>   Size: 913             Blocks: 8          IO Block: 4096   regular file
>> Device: 8,17    Inode: 131080      Links: 1
>> Access: (0755/-rwxr-xr-x)  Uid: ( 1000/akinori_physics)   Gid: ( 1000/akinori_physics)
>> Access: 2025-02-13 15:57:32.288154382 +0000
>> Modify: 2025-04-20 01:33:29.597602431 +0000
>> Change: 2025-04-20 01:33:29.597602431 +0000
>>  Birth: 2025-02-13 15:57:32.288154382 +0000
>> ```
> </details>

$\blacksquare$ **練習問題5:** 練習問題4 の `stat` コマンドの引数に存在しないファイルパスを入れるとエラーが出るはずです。このエラーを `2>` のリダイレクトで適当なファイルに書き込んでみてください。
> [!TIP]
> <details>
> <summary>解答例</summary>
> 
>```bash
>echo \#\#\# This is header. > staterr.txt
>stat nonefile 2>> staterr.txt # 追記にしたいので 2>>
>cat staterr.txt
>```
>> ```
>> ### This is header.
>> stat: cannot statx 'nonefile': No such file or directory
>> ```
> </details>


## パイプ：コマンドとコマンドを繋げる

これまで標準入力 `stdin` の方はあまり目立って出てきませんでしたが、コマンドとコマンドを繋げる処理を書く際には意識することになります。こちらもコマンドのフローは 左 → 右 が基本と考えて良いと思います。

### 基本構文

イメージ図を描くと以下のようになります：

<img src="figs/pipe1.drawio.svg" width=100%>

図に対応する処理のシェルでの書き方は以下：

```bash
コマンド1 | コマンド2
```

`|` をパイプと言います。パイプは何度でも繋げられます：

```bash
コマンド1 | コマンド2 | コマンド3 | ...
```

### いくつかのコマンドとパイプ使用例

#### `grep`: 文字列の検索

これは
```bash
grep 検索したい文字列
```
で標準入力から文字列を検索し、標準出力してくれるコマンドで、色々な場合で「何かを検索したい場合」にパイプを通して使われます：
```bash
何らかの文字が標準出力に出るコマンド処理 | grep 検索したい文字列
```
- 例：カレントディレクトリのファイルを検索する

    例えば以下のような状態だとします：
    ```bash
    ls 
    ```
    > ```
    > fuga.jpg  fuga.txt  hoge.jpg  hoge.txt  test.jpg  test.txt
    > ```
    この状態で、例えば `test` がつくファイルがあるかどうか：
    ```bash
    ls | grep test
    ```
    > ```
    > test.jpg
    > test.txt
    > ```

#### `less`: 読み取り専用のファイルオープン

これはファイルの内容を表示するコマンドで、`cat` に似ていますが、内容の表示のために別のモードに切り替わる点が違います。
```bash
less ファイルパス
```
モード終了は 終了：\<Q\>キー です。\<↑\>キー\<↓\>キーなどで、画面に表示しきれない部分にわたって見ることができます。これはファイルパスによる指定以外に、標準入力からの入力も受け付けるため、以下のようにして最終出力を確認できます：
```bash
何らかの文字が標準出力に出るコマンド処理 | less
```

なお、前回紹介した `head` と `tail` も似たように使えます。

- 例：カレントディレクトリの全ファイルの`stat`情報を一度に表示する

    例えば以下のような状態だとします：
    ```bash
    ls 
    ```
    > ```
    > fuga.jpg  fuga.txt  hoge.jpg  hoge.txt  test.jpg  test.txt
    > ```
    この状態で、次回説明する予定の `for` 文を用いて全ファイルにわたって `stat` コマンドを実行させます:
    ```bash
    for file in *; do stat $file; done
    ```
    > ```
    > ... いっぱいテキストが出てくるはず
    > ```
    これでも良いのですが、少し出力のテキストが長い気がします。場合によってはもっと大量のテキストになってしまう場合があるので、このような場合は `less` に通すとメインのシェルの画面が汚れません：
    ```bash
    for file in *; do stat $file; done | less   
    ```
    > ```
    > 内容がシェルとは別扱いで開かれます
    > <↑>キー <↓>キー で上下スクロール
    > <Q>キー で終了
    > ```
    ただ、もしかしたらシェル画面に出力が残っていた方が後から見て便利ということもあるかもしれないですし、記録に残す意味ではリダイレクトの方が良いかもしれません：
    ```bash
    for file in *; do stat $file; done > test.log
    less test.log
    ```
    > ```
    > 内容がシェルとは別扱いで開かれます
    > <↑>キー <↓>キー で上下スクロール
    > <Q>キー で終了
    > ```


$\blacksquare$ **練習問題6:** "/etc/services" という絶対パスで指定されるファイルがありますが、その中から "http" という文字列を含む行を検索してください。
> [!TIP]
> <details>
> <summary>解答例</summary>
> 
>```bash
>cat /etc/services | grep http
>```
>> ```
>># Updated from https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml .
>>http            80/tcp          www             # WorldWideWeb HTTP
>>https           443/tcp                         # http protocol over TLS/SSL
>>https           443/udp                         # HTTP/3
>>http-alt        8080/tcp        webcache        # WWW caching service
>> ```
>> ただし、ファイルの場合は直接 `grep` の引数にファイルパスを入れても良いです：
>```bash
>grep http /etc/services
>```
>> ```
>> 同じ出力結果
>> ```
> </details>

$\blacksquare$ **練習問題7:** "/etc" という絶対パスで指定されるディレクトリにはたくさんのファイル/ディレクトリがあります。この中から "python" という文字列が名前に含まれるファイル/ディレクトリを検索してください。
> [!TIP]
> <details>
> <summary>解答例</summary>
> 
>```bash
>ls /etc | grep python
>```
>> ```
>> python3
>> python3.12
>> ```
> こちらはパイプで繋ぐくらいしかないかと思います。`find` でも可能ですが、`find` だと "/etc" 直下のサブディレクトリまで全て検索しに行ってしまうので、今回の用途「このディレクトリ内だけで」検索したい場合は`ls` の方が良いです。
> </details>

$\blacksquare$ **練習問題8:** "/etc" という絶対パスで指定されるディレクトリ内のファイル/ディレクトリのうち、`ls -l` で表示されるファイルサイズが大きいものから順に10個を表示してください。
ヒント：
- `sort` というコマンドは、標準入力を受け取って、行を指定した順に並び替えて標準出力に返すコマンドです。今回用のオプション：
    - `-rn`: 数字が大きい順
    - `-k 番号`: 番号で指定された列の文字(上のオプション付きだと数字)を元に並び替える
- `head` コマンドは標準入力の最初の10行を標準出力に表示します。
> [!TIP]
> <details>
> <summary>解答例</summary>
> 
>```bash
>ls -l /etc | sort -rn -k 5 | head
>```
>> ```
>>-rw-r--r-- 1 root     root     75113 Jul 12  2023 mime.types
>>-rw-r--r-- 1 root     root     35647 Apr 13 07:18 ld.so.cache
>>-rw-r--r-- 1 root     root     12813 Mar 27  2021 services
>>-rw-r--r-- 1 root     root     12345 Feb 22  2024 login.defs
>>-rw-r--r-- 1 root     root     11424 May 23  2023 nanorc
>>-rw-r--r-- 1 root     root     10593 Mar 31  2024 sensors3.conf
>>-rw-r--r-- 1 root     root      9804 Apr  8  2024 sudo_logsrvd.conf
>>-rw-r--r-- 1 root     root      6288 Apr 13 07:07 ca-certificates.conf
>>-rw-r--r-- 1 root     root      5230 Apr  8  2024 manpath.config
>>-rw-r--r-- 1 root     root      4942 Jun 19  2024 wgetrc
>> ```
> </details>

### リダイレクトと組み合わせる

ここまでの説明から予想できると思いますが、パイプで処理した結果の出力をファイルに書き込むこともできます：

<img src="figs/pipe2.drawio.svg" width=100%>

```bash
コマンド1 | コマンド2 > ファイル名
```

パイプ処理は、2つ以上（複数回）あってもOKです。


$\blacksquare$ **練習問題9:** `hostory` コマンドは今まで実行したコマンドの履歴を標準出力するもので、下に行くほど新しいコマンドとして表示されます。この中から、`cat` を実行した履歴（とりあえずコマンド名に "cat" が含まれるもので良いです）だけ抜き取り、適当なテキストファイルに保存してください。
> [!TIP]
> <details>
> <summary>解答例</summary>
> 
> 保存してそのファイルを `less` コマンドで開いて見ます
>```bash
>history | grep cat > test.txt # これで保存
>less test.txt
>```
>> ```
>> # ... たくさん履歴が出る <Q>キーで元のシェルに戻る
>> 502  history | grep cat > test.txt
>> ```
> ただし、上の書き方だと、**偶然文字列の中にcatが含まれたもの** も入ってしまっています。例えば、"cat.jpg" のような名前の猫画像があったりすると、コマンドによらず、それもヒットしてしまいます。ですのでコマンド `cat` の履歴を表示するつもりでこのコマンドを打つ場合は注意が必要です。
> </details>

$\blacksquare$ **練習問題10:** パイプでは通常、標準出力 `stdout` しか繋ぐことはできません。しかし実はリダイレクトを使うと 標準エラー出力 `stderr` の方を次のコマンドの標準入力に使うことができます。それには
```bash
コマンドA 2>&1 | コマンドB
```
とします。`2>&1` は `stderr`=2 の値を `stdout`=1 にリダイレクトする、という意味です。`&` はファイルディスクリプタを表すシンボルです。適当にエラーが出るケースでこれを確かめて見てください。
> [!TIP]
> <details>
> <summary>解答例</summary>
> 
>```bash
>hoge
>```
>> ```
>> -bash: hoge: command not found
>> ```
>この表示をパイプに通して見ましょう。
>- `cat` に通す：
>
>例えば
>```bash
>hoge | cat
>```
>> ```
>> -bash: hoge: command not found
>> ```
>となるので、一見通っているように見えますが、これは `cat` で処理されて表示されているわけではありません。正しくは
>```bash
>hoge 2>&1 | cat
>```
>> ```
>> -bash: hoge: command not found
>> ```
>ですが、上の表示と同じなので差がわかりません。`grep` に通すとヒット文字に色がつくので分かりますが、このノート上で色を表示するのが難しいため、違う例にいきましょう。
>- `wc` に通す
>
>このコマンドは文字列の行数などを表示するものです。これに通すと違いがはっきりします。まず、リダイレクトなしでパイプに通すと：
>
>```bash
>hoge | wc
>```
>> ```
>> -bash: hoge: command not found
>>      0       0       0
>> ```
>となっています。これは
>- `hoge` の `stderr` が画面に表示され
>- `hoge` の `stdout` = `wc` の `stdin` は空文字のため、`wc` の計算結果はすべて0と表示
>
>ということです。リダイレクトすると：
>```bash
>hoge 2>&1 | wc
>```
>> ```
>>       1       5      31
>> ```
>となって、エラー文をそのまま入力できていることがわかります。
> </details>


## コラム：Unix哲学

Unixには長い歴史があり、今日のLinuxに至るまでにさまざまな人の手によって発展させられてきました。

> [!NOTE]
> ここまでで解説してきませんでしたが、このノートで解説してきた/解説していくシェルコマンドの始まりは Unix と呼ばれるOSです。Unixの歴史について私が呼んだことがある本を挙げておきます：
> - https://www.amazon.co.jp/Unix%E8%80%83%E5%8F%A4%E5%AD%A6-Truth-Legend-%E8%97%A4%E7%94%B0-%E6%98%AD%E4%BA%BA/dp/4048930508
> 
> 現在は Unix から派生した OS の Linux がよく使われるかと思います。このノートでもLinuxでの使用環境を想定していますが、Linuxの歴史については、上の書籍で書かれている時期よりは少し後のことで、例えば
> - https://ja.wikipedia.org/wiki/Linux%E3%81%AE%E6%AD%B4%E5%8F%B2
>
> などを見てみると状況が掴めるかもしれません。

その発展の最中で、これらのOSを使う上での考え方を明示的に表明する人々が現れました。その考え方をしばしば **Unix哲学** と呼びます。これは学問的な哲学という意味ではなく、あくまで考え方や思想をそのように呼んでいるだけのようです。これは必ずしも Unix/Linux の開発者たちの総意ではないのですが、的外れというわけでもないと私個人は考えています。特に
- OSを動かすための基本コマンド1つ1つはシンプルなものにして
- 複雑な処理はそれらをリダイレクトやパイプで繋いで表現する

というのは、今日の Unix/Linux ユーザーにとっては当たり前の考え方だと思います。これは **Small is beautiful.** と表現されることがしばしばあるようです。

[前のsection](1-1.md) | [次のsection](1-3.md)