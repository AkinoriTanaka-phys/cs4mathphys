# sshによる別マシンへのリモート接続

このノートでやること：
- ssh接続の仕組み
- 鍵の作成とリモート先との共有方法
- 接続方法、接続設定
- コラム：IPアドレスとDNSサーバー

## ssh接続とは

これまでは手元の（あるいはGoogle Cloud Shell上の）マシンの操作を取り扱ってきましたが、インターネットやローカルネットワークを介することで **別のマシン** の操作を手元のマシンから行うことができます。その際の通信中のセキュリティを担保するのが `ssh` コマンドや、それに類するコマンドによる通信です。これらの方法を習得すると
- 別のマシンの操作
- 別のマシンへのファイル転送、ファイルダウンロード

などを安全に行うことが可能になります。
> 攻撃される確率は0ではないですが、現状、その可能性は現実的ではない、という意味で安全です。

### 練習に使うサービス

本当は別マシンの操作も演習に入れたかったのですが、今回は色々な都合を考慮した結果、ひとまず **別マシンとの通信を確立する** ことだけを目標にします。これができれば、各自例えば
- 研究室のサーバーにどうやってログインするか
- クラウド計算機やスパコンをどうやって使うか

などの疑問はかなり解消するのではないかと思います。今回の演習では、
- 以下に紹介する無料でも使えるサービスへの登録ずみアカウント
- あるいは、ssh接続が可能な何らかのサーバー

が使用できること前提となります。以下ではいくつか登録するだけで使える（`git` 専用の）サービスを紹介します。
> `git` コマンドやその周辺の基本事項に関しては次回説明する予定です。

#### GitHub

最大手のgitホスティングサービスで、他にもホームページを作ることができたり、色々な機能があります。猫のマークで有名。2018年からMicrosoft傘下。

- 登録方法：https://github.co.jp/ から登録可能です。基本的に無料で使えるはずです。


#### Bitbucket

GitHubほど知られていない気がしますが、GitHubに無料のプライベートリポジトリがなかったときに私は使い始めました。今でも使っています。Atlassian傘下。

- 登録方法：https://bitbucket.org/product/ja の 「無料で入手する」から登録できるはず。

## `ssh`を用いた通信の基礎

`ssh`コマンド（Secure Shell の略）はあるマシンのシェル環境から別のマシンのシェル環境にネットワーク経由でログインすることのできるコマンドです：

<img src="figs/ssh.drawio.svg" width=80%>

[1-4. シェルの設定](../section1/1-4.md) の回で `sh` コマンドや `bash` コマンドを使いましたが、これらのコマンドと `ssh` は似ています：
- `sh` コマンドや `bash` コマンド
    - 手元の（ローカルな）PCの子プロセスとしてシェルを起動
- `ssh` コマンド
    - インターネットを介して別の（リモートの）コンピュータにログインし、そこでシェルを起動

接続方法はいくつかあるのですが、ここではセキュリティ面を考慮し、**公開鍵認証** を用いた接続方法を説明します。また、以下では同じ意味で別の用語が混ざっています（すいません）
- ローカル/クライアント：`ssh`コマンドを実行するコンピュータを指す
- リモート/ホスト：`ssh`コマンドを受け取る方のコンピュータを指す
    - なお、こちらでは `sshd` コマンドというものが動いています。

### 公開鍵認証による接続

以下を参考文献としました。（私は詳細については素人ですので）詳しくはそちらを見てみてください。：
- 文献（認証に限らず、暗号に関わる様々なことが平易に説明されています）：
    - https://www.hyuki.com/cr/
- ネットで読める記事：
    - https://speakerdeck.com/kaityo256/connecting-with-ssh-public-key-authentication
    - https://zenn.dev/tetsu1008/articles/8027cbab954e5e
    - https://zenn.dev/isosa/articles/77a70eb84f3ec2

大雑把にいうと、ネットを介した別のコンピュータへ（公開鍵認証方式で）ssh接続する際に起こっていることは
1. ネット通信そのものを暗号化する
    - `ssh` コマンドでは自動化されているため、通常ユーザーが意識しなくても良い
2. ホスト（接続先）が「本物かどうか」をクライアント（接続元）がチェックする
    - ホスト認証という
    - **ホスト（接続先）が所有している秘密鍵(Secret key)と公開鍵(Public key)** が使用される
3. クライアント（接続元）が「本物かどうか」をホスト（接続先）がチェックする
    - クライアント認証という
    - **クライアント（接続元）が所有している秘密鍵(Secret key)と公開鍵(Public key)** が使用される

です。1で通信経路を、2,3で通信の各両端を安全にしている感じです：

<img src="figs/ssh_1.drawio.svg" width=70%>

#### 秘密鍵と共有鍵

ここで **秘密鍵と共有鍵** という言葉が出てきましたが、これらは単なる **テキストファイル** です。`ssh` コマンドを使用する際は
- ホスト（接続先）側：
    ```
    /
    └── etc/
         └── ssh/
              ├── ...
              ├── ssh_host_***_key      # 秘密鍵
              └── ssh_host_***_key.pub  # 公開鍵
    ```
- クライアント（接続元）側
    ```
    ~
    └── .ssh
        ├── ...
        ├── id_***      # 秘密鍵
        └── id_***.pub  # 公開鍵
    ```
のような形で用意します。`***` には具体的な暗号方式が入る場合が多いようです。ユーザーとしてサーバーにログインする場合、上のホスト（接続先）側の鍵はすでにサーバーの側で用意してあるはずです。ですので、**ユーザーが用意しなくてはならないのはクライアント（接続元）側の鍵ペア**ということになります。

#### ホスト/クライアント認証で何が起こっているか

具体的な設定は以下で実践するとして、まず何が起こっているかを理解しておくと良いかと思います。


<img src="figs/ssh_3.drawio.svg" width=70%>

- 認証される側が何らかのメッセージを**秘密鍵を使って暗号化**（署名）し、相手に送る
- 暗号化されたメッセージを受け取った方は、**認証される側の公開鍵を使って復号化**し、正しいメッセージであることを確かめる

もし 認証される側が偽物（緑色） だとしても、公開鍵の方法だけから対応する秘密鍵や正しいメッセージを偽造することは数学的に困難であるようになっています：

<img src="figs/ssh_4.drawio.svg" width=70%>

この絵のポイントは、公開鍵の情報だけから
1. 秘密鍵を作る
2. 正しいメッセージになるような暗号を直接作る
3. 送信元のメッセージで「別の秘密鍵で暗号化→向こうで正しいメッセージが複合化される」ようなものを作る

のどれも困難なようになっているということです。ただし、当然ですが**秘密鍵が流出するとこの限りではありません**。やることをまとめると：
- 公開鍵（`.pub`拡張子ファイル）は相手に渡す
- 秘密鍵（拡張子なしファイル）は相手に渡さない

ということになります。もし秘密鍵が漏洩したかもしれないと思ったら、作り直して以下の作業をやり直してください。

### 接続前の実践手順

では具体的に、アクセスする側から必要な手順をなぞっていきましょう。

#### 秘密鍵/公開鍵 の作成

以下のコマンドで作ります：
```bash
ssh-keygen [オプション]
```
オプションには色々あります：

- 具体例：オプションなし
    ```bash
    ssh-keygen 
    ```
    > ```
    > Generating public/private ed25519 key pair.
    > Enter file in which to save the key (/home/ユーザー名/.ssh/id_ed25519): 
    > ```
    > これは、とりあえず入力をせずに\<enter\>でOKです（デフォルトの場所以外に鍵を保存する場合のみ入力）。すると、`~/.ssh`以下に鍵のペアが適当な名前で作成されます。もしこのディレクトリがない場合は自動作成され、
    > ```
    > Created directory '/home/ユーザー名/.ssh'.
    > ``` 
    > のようなメッセージが出ます。次に以下のような入力を迫られます
    > ```
    > Enter passphrase (empty for no passphrase): 
    > ```
    > これは **パスフレーズ** と呼ばれる文字列の設定です。パスフレーズは **秘密鍵を使用する際に入力するパスワード** で、これを設定しておくと万が一秘密鍵が漏洩してもパスフレーズがないと中身がわかりません。ですので基本的には設定しておくことをお勧めします（ただし、ssh接続の度に入力を求められます）。これを入力し\<enter\>すると、確認のためもう一度同じパスフレーズを入力しろと言われます：
    > ```
    > Enter same passphrase again: 
    > ```
    > これを入力し\<enter\>すると、晴れて以下のようなメッセージが出て、鍵が作成されます：
    > ```
    > Your identification has been saved in /home/ユーザー名/.ssh/id_ed25519
    > Your public key has been saved in /home/ユーザー名/.ssh/id_ed25519.pub
    > The key fingerprint is:
    > SHA256:******************************************* ユーザー名@cs-************-ephemeral-xaol
    > The key's randomart image is:
    > +--[ED25519 256]--+
    > |    *********  **|
    > |   ***** * *  ***|
    > |  * * * * * * * *|
    > |   * * * * * * * |
    > |    *****   *****|
    > |     * * * * * **|
    > |          * * * *|
    > |               * |
    > |                 |
    > +----[SHA256]-----+
    > ```
    > 最初の2行は「ここに作られた鍵を置いたよ」という内容です。その後に出ている
    > > ```
    > > The key fingerprint is:
    > > SHA256:******************************************* ユーザー名@cs-************-ephemeral-xaol
    > > ```
    > の意味ですが、これは公開鍵はそのままだと長すぎて人間の目で同じものを判別できないため、適当なハッシュ関数（ここでは `SHA256`）を用いてそれを圧縮表示したもので **公開鍵のフィンガープリント（指紋）** と呼ばれます。この下の
    > ```
    > The key's randomart image is:
    > +--[ED25519 256]--+
    > |    *********  **|
    > |   ***** * *  ***|
    > |  * * * * * * * *|
    > |   * * * * * * * |
    > |    *****   *****|
    > |     * * * * * **|
    > |          * * * *|
    > |               * |
    > |                 |
    > +----[SHA256]-----+
    > ```
    > も同様に公開鍵のフィンガープリントを表しており、より判別しやすいように、あるアルゴリズムで視覚化したものです。
    > 
    > この後実際に鍵が作成されたかどうか確認すると：
    > ```bash
    > ls .ssh
    > ```
    > > ```
    > > id_ed25519  id_ed25519.pub
    > > ```
    > となっていて、確かに作成されていることがわかります。

> [!WARNING]
> - Google Cloud Shellの（エフェメラルモードでない）通常モード で動かしている場合、公開鍵/秘密鍵が 手元のPC以外の場所に保存されることになるため、そのまま放置すると（Googleの認証がいくら堅牢とはいえ）情報漏洩リスクが生じます。ですので、**演習が全て終わったら、念の為全ての鍵を消去しておくことを推奨**します。これはセキュリティ上のリスクを回避するための注意喚起です。エフェメラルモードの場合は勝手に消えるので大丈夫かと思います。

$\blacksquare$ **練習問題1:** とりあえずデフォルトで鍵ペアを作ってみてください。作成後にも

```bash
ssh-keygen -lf ~/.ssh/鍵名.pub
```
で対象の公開鍵のフィンガープリントを見ることができます（`.pub`を忘れて、秘密鍵パスを指定しても同じ出力）。これを見て、作成時に表示されたものと同じことを確認してください。

> [!TIP]
> <details>
> <summary>解答例</summary>
> 
> 例えば「例」で作った鍵のフィンガープリント確認は
> ```bash
> ssh-keygen -lf ~/.ssh/id_ed25519.pub
> ```
> > ```
> > 256 SHA256:FE7EQBTKJ5bUXFxlziILKHfaaWfP2U1vxQjLVU45MdY ユーザー名@cs-152661343926-ephemeral-xaol (ED25519)
> > ```
> のようになるはずです。
> </details>

$\blacksquare$ **練習問題2:** 鍵の名前を指定して作るには

```bash
ssh-keygen -f ~/.ssh/鍵名
```

です。これで適当な名前で新たに鍵を作って、その名前の鍵ペアが作られることを確かめてください。

> [!TIP]
> <details>
> <summary>解答例</summary>
> 
> ```bash
> ssh-keygen -f ~/.ssh/test
> ```
> > ```
> > Generating public/private ed25519 key pair.
> > Enter passphrase (empty for no passphrase): 
> > Enter same passphrase again: 
> > Your identification has been saved in /home/ユーザー名/.ssh/test
> > Your public key has been saved in /home/ユーザー名/.ssh/test.pub
> > The key fingerprint is:
> > ...
> > ```
> パスフレーズは適当に設定してください。
> この後、`~/.ssh` を見てみると：
> ```bash
> ls ~/.ssh
> ```
> > ```
> > id_ed25519  id_ed25519.pub  test  test.pub
> > ```
> となって、「例」で作った鍵に加えて `test` から始まるファイルが二つできているのがわかります。
> </details>

#### 公開鍵の登録


<img src="figs/ssh_6.drawio.svg" width=70%>

作成した公開鍵（`id_***.pub` の中身のテキスト＝長い1行のテキスト全て）を、ホスト（接続先）の以下のパスのファイル `authorized_keys` に書き込みます：
```
# ホスト（接続先）の環境
/
├── etc/
|    └── ssh/
|         └── ... # ホストの鍵情報など
└── home/
     ├── ユーザー1
     ├── ユーザー2
     ├── ...
     └── 自分がログインするユーザー
          └── .ssh/
                └── authorized_keys # このファイル
```

なお、ここには複数の公開鍵を改行区切りで複数書き込むことができます（これは複数のマシンからログインする可能性がある場合に使います）：
```
# ファイル authorized_keys の中身
公開鍵1 (対象の `***.pub` の中身のテキスト全て)
公開鍵2 (対象の `***.pub` の中身のテキスト全て)
...
```

#### 自分でホスト（接続先）に書き込めない場合

その接続先サーバーの管理者がいるはずです。その人に相談しましょう。大体は「公開鍵をください」と言われて、そのテキストが管理者によって接続先のあなたのホーム以下の `authorized_keys` に書き込まれます。

#### GitHub/Bitbucket での公開鍵の登録

これらのサービスのサーバーには直接上記のファイルに書き込むことはできませんが、ブラウザからアクセスできる、それぞれのアカウントのページから公開鍵の登録が可能です。

- GitHubの場合（2025年8月）
    1. ホーム → 右上の丸い自分のアイコン（設定していない場合はランダムな模様）をクリック 
    2. Settings → 左のコラムから "SSH and GPG keys" をクリック
    3. "New SSH key" をクリックし、飛ばされた先で
        - Title: なんでも（多分空欄でも）良いです
        - Key type: "Authorization key" 
        - Key: 登録したい公開鍵をペースト

        ののち、Add SSH key をクリック
    4. なお、登録した鍵の削除は3の画面で登録された鍵の "delete" ボタンをクリックして進めばOK
- Bitbucketの場合（2025年8月）
    1. Atlassian のホーム → Bitbucket を選択
    2. 右上の歯車のマークをクリック → Personal Bitbucket settings をクリック
    3. 左のコラムから "SSH 鍵" をクリック → Add key をクリックし
        - Name: なんでも（多分空欄でも）いいです
        - SSH Public Key*: 登録したい公開鍵をペースト
        - Expiry*: 有効期限を選択

        ののち Add key をクリック
    4. なお、登録した鍵の削除は3の画面で登録された鍵の "delete" ボタンをクリックして進めばOK

とすると良いです。

> [!WARNING]
> - 以後、公開鍵を適当なサーバー（GitHub/Bitbucket）に登録してssh接続する練習をしますが、**Google Cloud Shellから接続する場合は演習（練習問題8まで）を終えた後にサーバー（GitHub/Bitbucket）から公開鍵を削除しておくこと**を推奨します。これはセキュリティ上のリスクを回避するための注意喚起です。
> - ただし、もちろん練習ではなく実際に使う場合は、削除する必要はありません。その際はGoogle Cloud Shellではなく、ぜひ手元のPCからのアクセスに制限してください。（Google Cloud Shellがクラッキングを受ける可能性は低いと思いますが、いつでも動きうるコンピュータ環境にはできるだけ他の場所と連携する鍵を置かないようにしたいです。）


$\blacksquare$ **練習問題3:** GitHub に公開鍵を登録してください。

> [!TIP]
> <details open>
> <summary>解答例</summary>
> 
> 略
> </details>


$\blacksquare$ **練習問題4:** Bitbucket に公開鍵を登録してください。

> [!TIP]
> <details open>
> <summary>解答例</summary>
> 
> 略
> </details>

### 接続の実践手順

まだ自分の公開鍵をホストに置いただけで、ホストの公開鍵をクライアント（接続する側）に置いていませんが、**sshでは初回接続の際にホストの公開鍵を登録します**。実際の接続には `ssh` コマンドを用います。最も単純な接続コマンドは以下です：

```bash
ssh ユーザー名@ホスト名
```

クライアント認証の段階で秘密鍵が必要なので、パスフレーズに入力を求められます。
また、**登録した公開鍵がデフォルト設定でのパス（名前）でない場合は、 `-i 対応する秘密鍵のパス` のオプション引数が必要です**。

#### 初回の接続と注意

まずホストの公開鍵が送られてきますが「本当に接続したいホストかどうか」をチェックしなければいけません：

<img src="figs/ssh_5.drawio.svg" width=90%>

初めて接続するホストの場合は、`ssh`コマンドを実行すると以下のような確認を求めるメッセージが出ます：
```bash
The authenticity of host '[ホスト名]' can't be established.
[ホスト鍵の種類] key fingerprint is [ハッシュ関数の種類]:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
Are you sure you want to continue connecting (yes/no/[fingerprint])?
```
ここの情報が確かに接続先の公開鍵情報と一致していれば `yes` と打って\<enter\> でOKです。

- `[]`で囲んだ部分は場合によって異なります。
- この後に送られてくる情報を元にホスト認証を行います。
- 接続先が本物かどうかを確認するために **ホスト側の公開鍵のフィンガープリント（指紋）** が `[ハッシュ関数の種類]:xxx...` 部分に表示されています。
    - もし攻撃者がいた場合、**ホスト名やIPアドレスの入力が正しかったとしても「偽のホスト」にユーザーを誘導できる可能性がある**ため、それに対する防衛です。**GitHubやBitBucketのホスト側の公開鍵のフィンガープリントは検索すると出てきます**。また、個別の計算サーバーなどの場合はフィンガープリントは管理者に問い合わせれば教えてくれるはずです。
    <img src="figs/ssh_7.drawio.svg" width=90%>

    - ホスト側の公開鍵のフィンガープリントを偽造することは現実的なレベルでは不可能とされています（ペアとなる秘密鍵で署名をしなければならず、公開鍵だけからその秘密鍵を作成するのが困難なため）。
    - **フィンガープリントが異なる「怪しい接続先」には接続しないようにしてください。** もし間違ってそのような接続先に `yes` をしてしまった場合は以下の部分が参考になります。
- なお、最後の質問に `yes` と答えると、接続が開始され、クライアント（ユーザー）側のディレクトリで：
    ```
    ~
    └── .ssh
        ├── ...
        ├── id_***      
        ├── id_***.pub  
        └── known_hosts         # <- このファイル
    ```
    が存在していなければ作成され、そこに
    ```
    # ~/.ssh/known_hosts の中身
    [ホスト名1] フィンガープリント1 (この形式以外もある)
    [ホスト名2] フィンガープリント2 (この形式以外もある)
    ...
    ```
    のような形で「既知のホスト」として登録されます。2回目以降はこの情報を参照するため、「このホストと接続して良いですか？」とは聞かれなくなります。
- もし間違ってフィンガープリントが異なる「怪しい接続先」に対して `yes` で初回接続してしまった場合でも、上で `~/.ssh/known_hosts` に追加された「怪しい接続先情報」の行を削除すれば初回接続の状態に戻ります。あるいは以下のように `-R` オプション付きで `ssh-keygen` コマンドを使っても消去できるようです：
    ```bash
    ssh-keygen -R ホスト名
    ```
    `ユーザー名@`は含めなくて良いようです。このコマンドで消すと、万が一間違って消してしまった時のためにバックアップファイル `~/.ssh/known_hosts.old` が作成されます。


#### 2回目以降の接続と注意

`~/.ssh/known_hosts` に接続先情報が書き込まれた後の接続時には、こちらの秘密鍵のパスフレーズだけ入力すれば基本的には問題なく接続できます。ただし例外があって、それは `ssh` コマンドを実行した際に**送られてくるホスト公開鍵情報が`~/.ssh/known_hosts` に追加されたものと異なる場合**です。その場合は以下のメッセージが表示され、コマンド実行がストップされます：
```bash
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the [送られてきたホスト鍵の種類] key sent by the remote host is
[ハッシュ関数の種類]:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
Please contact your system administrator.
Add correct host key in ~/.ssh/known_hosts to get rid of this message.
Offending [こちらで保存しているホスト鍵の種類] key in ~/.ssh/known_hosts:[行数]
[こちらで保存しているホスト鍵の種類] host key for [ホスト名] has changed and you have requested strict checking.
Host key verification failed.
```

このようなことが起こる可能性は二つあります：

<img src="figs/ssh_8.drawio.svg" width=100%>

1. 悪意を持った攻撃者が接続したいホストのフリをしている場合
2. 接続したいホストの鍵ペアが変更された場合

1つ目の懸念があるため、`ssh`コマンド実行が自動ストップするというわけです。2つ目の可能性もあり得るので、このようなメッセージが出た場合は
- GitHubやBitbucketの場合は公式のアナウンスで「鍵を変更しました、フィンガープリントはyyyyです」という声明が出ていないか探す（もし見つからなければ1の攻撃を疑う）
- サーバーの管理者に問い合わせる

のいずれかを行なってください。もし1つ目の「接続したいホストの鍵ペアが変更された場合」の確認が取れたら、`~/.ssh/known_hosts` の古い情報は削除（対象のホストの行を削除か、`ssh-keygen -R ホスト名` ）し、再度 `ssh` コマンドを実行し、初回接続と同じ操作をします。

- 例：GitHubの自分のアカウントに接続
    ```bash
    ssh -T git@github.com # -T オプションが必要です
    # 登録した鍵に名前をつけた場合は -i `使う鍵のパス` のオプションも追加してください。
    ```
    > ```
    > Enter passphrase for key '[GitHubに登録した公開鍵のペアである秘密鍵のパス]': ここにパスフレーズを打ち込んでenter
    > Hi あなたのアカウント名! You've successfully authenticated, but GitHub does not provide shell access.
    > ```

$\blacksquare$ **練習問題5:** GitHubに接続 
> [!TIP]
> <details open>
> <summary>解答例</summary>
> 
> 略
> </details>

$\blacksquare$ **練習問題6:** Bitbucketに接続 

こちらは
```bash
ssh -T git@bitbucket.org
```
で接続確認できるはずです。

> [!TIP]
> <details>
> <summary>解答例</summary>
> 
> 成功すると
> ```
> Enter passphrase for key '[GitHubに登録した公開鍵のペアである秘密鍵のパス]': ここにパスフレーズを打ち込んでenter
> authenticated via ssh key.
> 
> You can use git to connect to Bitbucket. Shell access is disabled
> ```
> と出るようです。
> </details>

### 接続手順を簡単化する方法

#### ssh/config の設定

ここまでの手続きで、とりあえず `ssh` コマンドを使うことはできるようになります。しかし慣れてくると以下のような悩み（？）が生じます：
- いろんなサーバーにアクセスするようになると、 `ssh ユーザー名@ホスト名` の `ユーザー名@ホスト名` を覚えられない
- セキュリティの観点から、接続先ごとに異なる鍵ペアを用意した方が良いが、鍵ペアが複数 `~/.ssh` に存在することになり、管理が面倒

などです。概ね「たくさんの情報を覚えていられない」という悩みを書きましたが、よくある解決策はメモ書きに書き留めておくということでしょう。`ssh`コマンドでは実は
```
~
└── .ssh
    ├── ...
    ├── id_***      
    ├── id_***.pub  
    ├── known_hosts
    └── config       # このファイル（なければ作成する）
```
に以下のような「メモ書き」フォーマットで情報を記入しておくと、自動でこのメモを読んで接続してくれます。
```bash
# ~/.ssh/config
# これはコメント 
Host エイリアス名1       # エイリアス名は重複しなければ、なんでもOK
    HostName     ホスト名1
    User         ユーザー名1
    IdentityFile ユーザーの秘密鍵のパス1
    # 他にも色々なオプションが書けます

Host エイリアス名2
    HostName     ホスト名2
    User         ユーザー名2
    IdentityFile ユーザーの秘密鍵のパス2

...
```
上のような場合は、例えば `ssh エイリアス名1` = `ssh ユーザー名1@ホスト名1 -i ユーザーの秘密鍵のパス1` となります。


#### ssh-agent の使用

ここまでくると、秘密鍵の解答に使うパスフレーズの入力も面倒になってきます。`ssh-agent` コマンド を使うと、**使用しているコンピュータのメモリ上に秘密鍵を配置**し、1回のパスフレーズ入力だけで以後はメモリ上にロードされた秘密鍵を使ってくれるようになり便利です。ですが当然セキュリティは下がるので、通常は使用時間を制限するなどして、メモリ上から秘密鍵情報を消去するように運用します。ここでは使い方は解説しませんが、いつか役に立つ時が来るかもしれません。

$\blacksquare$ **練習問題7:** GitHubへの接続の際のコマンド
```bash
ssh -T git@github.com # -T オプションが必要です
```
を参考にして、`~/.ssh/config` を編集してGitHubに

```bash
ssh -T github
```
で接続できるようにしてください。

> [!TIP]
> <details>
> <summary>解答例</summary>
> 
> GitHubへの接続の際のコマンド
> ```bash
> ssh -T git@github.com # -T オプションが必要です
> ```
> を見ると、ホスト名=`github.com`、**ユーザー名=`git`** になっています。ユーザー名が自分のGitHubアカウント**ではない**点が混乱しがちですが、そういうものだと思ってください。なので `~/ssh.config` には 
> 
> ```
> Host github
>         Hostname github.com
>         User git 
>         IdentityFile ~/.ssh/鍵名
> ```
> のように書けば良いことになります。複数鍵がある場合、`IdentityFile`で鍵を指定した方がスムーズです。
> 
> </details>

$\blacksquare$ **練習問題8:** `~/.ssh/config` を編集してBitbucketに接続 
> [!TIP]
> <details>
> <summary>解答例</summary>
> 
> GitHubの場合に似ていて、通常のコマンドは
> ```bash
> ssh -T git@bitbucket.org
> ```
> だったので、ホスト名とユーザー名を読み取って
> ```
> Host bitbucket
>         Hostname bitbucket.org
>         User git 
>         IdentityFile ~/.ssh/鍵名
> ```
> のように書けば良いことになります。
> </details>


## 接続先とファイルの送受信をする

`ssh` コマンドは基本的に「向こうの環境にログイン」してリモートで遠隔のコンピュータの操作をするためのコマンドで、あたかも手元で `bash` コマンドや `sh`コマンド（[1-4参照](../section1/1-4.md)）を実行したかのような感覚で使えたのでした。

`cp` コマンドのようなこと（ファイルの転送）を [ローカル] $\leftrightarrow$ [リモート] でやりたい場合もあるでしょう。それも同様に `ssh` と同じ安全な仕組みで実行できます。

### `scp`

一番素朴なのはこのコマンドです。使い方は：

```bash
scp コピー元 コピー先
```
です。これは [ローカル] $\leftrightarrow$ [リモート] のどちら向きにでも使えます。
- [ローカル] = `ローカルのファイルパス`
- [リモート] = `ユーザー名@ホスト名:ホストのファイルパス`
    - なお、`~/.ssh/config` でエイリアスを設定している場合は `ユーザー名@ホスト名` は `エイリアス名` だけで良いです。

### `rsync`

`scp` は基本的に「毎回丸々のコピーを送る」ものです。
もう少し効率的なのが `rsync` で、使い方は：

```bash
rsync コピー元 コピー先
```
です。このコマンドは「転送先との差分だけ送る」ものらしいです。リモートの指定方法は `scp` と同じです。

転送するファイルサイズが大きい場合、ネット状況によっては接続が中断してしまうことがありますが、そのような場合に有用です。


$\blacksquare$ **練習問題9:** 安全のため、練習問題にてGitHub/Bitbucketに登録した公開鍵を削除し、練習に使ったクライアント（接続元）の鍵も削除してください。
> [!TIP]
> <details open>
> <summary>解答例</summary>
> 
> 略。
>
> 何度も言うようですが、ご自身で実際にこれらのサービスを使う場合は鍵を削除してはいけません。実際に使う際は、鍵漏洩のリスクを少しでも減らすため手元のPCからアクセスすることを推奨します。
> </details>

$\blacksquare$ **練習問題10:** GitHub/Bitbucketではホスト（接続先）に実際に入って、そこで作業することはできません。そこで、研究室のサーバーや、共用サーバーなどでssh接続できるものがないか探し、そこに公開鍵を登録することでsshによるログインを実行してみてください（この場合、手元のPCから接続すること推奨です）。そこで `scp` や `rsync` を使ってファイル転送してみてください）。
> [!TIP]
> <details open>
> <summary>解答例</summary>
> 
> 略。
>
> 大学などの教育機関であれば、探せば共用サーバーがあると思います。
> </details>

## コラム1：ホスト名とIPアドレス

ssh コマンドでホストと接続する際、最低限のコマンドは

```bash
ssh ユーザー名@ホスト名
```

なのでした。例えば `ホスト名` は
- GitHubであれば `github.com`
- Bitbucketであれば `bitbucket.org`

でした。（実際には、これらは`ホスト名`というよりは`ドメイン名`と呼ばれますが）実はこの文字列情報だけでこれらのホストにアクセスしているわけではありません。

インターネットを介した他のサーバーとのやり取りには **IPアドレス(インターネット・プロトコル・アドレス)** と呼ばれる文字列が使われます。IPv4 と呼ばれる形式では、次のように 4つの数値を `.` で区切って表記します：
```
xxx.xxx.xxx.xxx # xには数字が入る
```
`xxx`のスロットには`000`から`255`まで（8ビット）の数字を入れることができます。すなわち表現できる独立なアドレスは $`256^4 = 4294967296`$ 個ということになります。実際には、この組み合わせを自由に使えるわけではないのですが、そのあたり詳しく知りたい方は 

- https://ja.wikipedia.org/wiki/IPv4

などをみてください。

<blockquote>
<details>
<summary>IPv6についてのコメント</summary>

最近では上記の表現規則だと世界中のアドレスを指定するのに不足する懸念が生じている（実際にすでに枯渇している）ために IPv6 というフォーマットへの置き換えが進められています：

- https://ja.wikipedia.org/wiki/IPv6

</details>
</blockquote>

ssh接続の際にも（というか、インターネットをブラウザから閲覧する場合にも）ドメイン名やホスト名からIPアドレスに変換され、そこで改めてそのアドレスの示すサーバーにアクセスする、という経路をとっています。

ドメイン名/ホスト名 → IPアドレスの変換（これを**名前解決**と言います）は別のサーバーが請け負っており、このサーバーを **DNSサーバー** (Domain Name System サーバー)と言います。ただし以下で説明するローカル通信など、簡単な名前解決であればコンピュータが自動で処理している場合もあるようです。

### ローカルIPアドレス

一方で、外部のインターネットには行かないものの、ローカルネットワークで接続されている状況では、そのローカルネットワーク内の位置を指し示すIPアドレスを使います。それが**ローカルIPアドレス**です。
> これに対し、外のインターネットでの位置を示すIPアドレス（上で説明したもの）をグローバルIPアドレスと言います。

ローカルIPアドレスを使うと、同じローカルネットワークにつながっているマシン同士でやり取りができます。特に**片方が ssh 接続を受け入れる設定（sshdの起動）をしておけば**、以下のコマンドでそのマシンにログインすることが可能です：

```bash
ssh ユーザー名@ログインしたいマシンのローカルIPアドレス
```

ローカルIPアドレスは簡単に調べることができるので、研究室内/家庭内でのネットワーク経由で色々なマシンを動かしたい時に役立つかもしれません。

また、ローカルIPアドレスであっても `ホスト名` だけで名前解決できる場合が多いです。

## コラム2：sshポートフォワーディング（トンネリング）

sshコマンドのポートフォワーディング機能（例：`-L` オプション）を使うと、ローカルPCのあるポート番号B と、SSHでログインしたサーバー上（またはそのサーバーから到達可能なホスト）のポート番号A をトンネルで接続することができます。

ポート番号のことを説明していないため、ここでは説明しませんが、詳しくは以下など見てみてください：

- https://tech-lab.sios.jp/archives/37377
- https://qiita.com/miyuki_samitani/items/07c8b05f74dca25b33d0
- https://runningdog.mond.jp/blog/2024/09/15/ssh-portforwarding/

これを用いると例えば
- サーバー上で立ち上げた Jupyter Notebook を、手元のブラウザから安全に操作する
- サーバー上で起動したローカルLLMのWeb UIを、あたかもChatGPTのようにブラウザから利用する

などが可能です。