# gitによるバージョン管理

このノートでやること：
- バージョン履歴の残し方
- バージョン枝の操作方法
- 過去バージョンに戻る方法
- ホスティングサーバーと繋げる
- コラム：お作法いろいろ

## バージョン管理とは

何らかの書類（論文/事務書類/発表スライド...何でも良いです）を作成する際、こんな経験はないでしょうか？
- 一旦完成させたと思って、"完成版.pdf"のような名前で保存
- 翌日、修正の必要に駆られ、修正、"完成版_final.pdf"のような名前で保存
- さらに翌日、再度修正し、"完成版_final_2.pdf"のような名前で保存
- ...

流石に自分で名前をつけている場合はどれが「本当の完成版」かわかると思いますが、手元の環境が汚くなりますし「どれが本当の完成版だったかな？」と考えるステップが入ってしまいます。また、これがもし複数名の手が入るようなものの場合は最悪です。

そのような悲劇を防ぐために使うのが **バージョン管理システム** です。いろいろありますが、このノートでは現在最もよく使われている git について説明します。

### gitとは

かなり詳細かつわかりやすい公式の解説があります：

- https://git-scm.com/book/ja/v2

これを読んで自分で勉強するのが一番ですが、このノートでは実際に手を動かしながらその使い勝手を体験してもらうことを目的としています。

## `git` の使い方

Gitはバージョン管理システムの一種です。もしGit（`git`コマンド）が利用可能であれば

```
which git
/usr/bin/git
```
のような表示が出てきます。Google Cloud Shell では最初から入っているようです。

### 最初にやる設定

`git` コマンドではディレクトリを管理対象とします。例えば、以下のような感じです：

```
/
├── ...
│   ├── ...
│   │   └── 管理ディレクトリA
│   │       ├── ...
│   │       └── ...
│   └── 管理ディレクトリB
│       ├── ...
│       └── ...
└── 管理ディレクトリC
    ├── ...
    └── ...
```

このように、ディレクトリ単位で別々にバージョン管理することが可能です。また、管理対象のディレクトリの中にサブディレクトリがあっても構いません（むしろ管理をやりやすくするため、サブディレクトリで構造化するのは常套手段です。）

バージョン管理の際は、各ディレクトリごとに、内部状態のスナップショット履歴を、各ディレクトリ直下（`.git`という隠しディレクトリ）に記録していく構造になります：

<img src="figs/git.drawio.svg" width=100%>

このようにしておいて、
- どの時刻のスナップショットにでも戻ることができるようになります。
- 各スナップショットで、同一ファイル名の者の内容が変化していてもOKです。していなくてもOKです。
- また、スナップショット履歴は単純な1方向だけのものではなく、途中で枝分かれするなどの状況も取り扱います。

> - 厳密には、変更のないファイルは前回のコミットで保存された実体データをそのまま参照（再利用）します。そのため、毎回すべてのファイルを丸ごと保存し直すのではなく、効率的にその時点の「スナップショット」を表現する仕組みになっています。
> - gitの文献によっては履歴の矢印が 旧 ← 新 のように上の図とは逆向き（時間方向と逆）になっているものがあります。これは内部のデータ構造が本当はそのようになっているからですが、ここでは初学者向けのわかりやすさを優先し、時間順の向きに矢印を書きます。

#### 管理を始めるコマンド：`git init`

管理対象のディレクトリを指定するコマンドが `git init` です。使い方は2つです

- すでに存在するディレクトリに入って `git init`
    ```bash
    cd 管理したいディレクトリのパス
    git init
    ```
    この後に色々メッセージが出てきます。
- ディレクトリ名を指定して `git init`
    ```bash
    git init 管理したいディレクトリのパス
    ```

すると `管理したいディレクトリ` の直下に `.git` という隠しディレクトリが作成されます（これを**リポジトリ**と言います）。ただし、この段階までだと「このディレクトリを管理する」と宣言しただけで「どのファイルを管理するか」までは指定していない状態です。

<img src="figs/git_init.drawio.svg" >

#### 管理のための設定：`git config`

`git` コマンドでバージョン管理を始めるためには、「その編集を行ったのは誰か」の情報を登録しておく必要があります。最低限以下を叩いておくとOKです。

```bash
git config --global user.email "連絡用メールアドレス"
git config --global user.name "名前"
```

##### グローバル設定と設定ファイルの置き場

ここで `git config` に `--global` のオプションをつけると、

```
~/.gitconfig
```
という、ホームディレクトリ直下の隠しファイルに設定情報が書き込まれます。今回の練習で使う最低限の `連絡用メールアドレス` と `名前` はそう変わることはないはずなので、ここに書き込んでおくというわけです。

##### ローカル設定と設定ファイルの置き場

`git config` に `--local` のオプションをつけると、

```
管理対象のディレクトリ/.git/config
```

という隠しディレクトリに設定情報を書き込みます。これは **この管理対象ディレクトリ内だけで有効な設定** を描く場所で、ローカル設定情報を優先しつつ、追加でグローバルで設定した情報も使われるようです。

> なお、そのマシンを使っているユーザー全員に適用される設定：`--system` というオプションもあるようですが、今回は使いません。

$\blacksquare$ **練習問題1:** 適当なディレクトリを作成し、それをgitによる管理対象にしてください。
> [!TIP]
> <details>
> <summary>解答例</summary>
> 
> 
> まずは適当なディレクトリを作成し、その中に入りましょう：
> ```bash
> mkdir ~/exercise1
> cd ~/exercise1
> ```
> この状態で
> ```bash
> git init
> ```
> > ```
> > Initialized empty Git repository in /home/ユーザー名/exercise1/.git/
> > ```
> 動かしているコンピュータ上で初めて `git` コマンドを使い出した場合はさらに
> ```bash
> git config --global user.email "連絡用メールアドレス"
> git config --global user.name "名前"
> ```
> もやっておくと良いでしょう。このコマンドが反映されたかどうかは
> ```bash
> git config user.email
> ```
> あるいは
> ```bash
> git config user.name
> ```
> で確認できます。
> </details>

$\blacksquare$ **練習問題2:** グローバル設定で登録した名前と、ローカル設定した名前のどちらが優先されるか調べてみてください。カレントディレクトリで
```bash
git config user.name
```
を実行すると、その場所でのgitコマンドが認識するユーザー名が出力されます。
> [!TIP]
> <details>
> <summary>解答例</summary>
> 
> まずグローバル設定に名前を設定します：
> ```bash
> git config --global user.name "test"
> ```
> その後、練習問題用のディレクトリを作り、git管理対象にします：
> ```bash
> mkdir ~/exercise2
> cd ~/exercise2
> git init
> ```
> > ```
> > Initialized empty Git repository in /home/ユーザー名/exercise2/.git/
> > ```
> このあと、このディレクトリのgit管理名をローカル設定で書き込んでみます：
> ```bash
> git config --local user.name "changed name"
> ```
> これでgitが認識している名前を見てみましょう：
> ```bash
> git config user.name
> ```
> > ```
> > changed name
> > ```
> ホームに戻って `user.name` をみてみると、元のままのはずです：
> ```bash
> cd
> git config user.name
> ```
> > ```
> > test
> > ```
> このことから、デフォルトはグローバル設定、ローカルで別途設定した場合はそちらが優先されることがわかります。
> </details>


### バージョン履歴の残し方

`git` ではバージョン履歴を残すので、当然、過去の履歴に戻ったり、過去の間違いを修正したりすることができますが、そのためにはまず、管理対象にファイルを追加したり、実際にバージョン履歴を残さないことには始まりません。なので、まずは管理対象にファイルやディレクトリを含めて、実際にバージョン履歴を残していくやり方を説明します。

#### ステージとコミット

管理対象のスナップショットを作成するには、
1. 管理したいファイルを「ステージ」する
2. ステージしたファイルを「コミット」する

の二段階で行います：

<img src="figs/git_staging.drawio.svg" width=70%>




##### ステージする際に使用するコマンド

- ファイルをステージに上げる
    ```bash
    git add ファイルパス1 ファイルパス2 ... # 複数同時に指定可能
    ```
- ステージに上げたファイルをステージから外す
    ```bash
    git restore --staged ファイルパス1 ファイルパス2 ... # 複数同時に指定可能
    ```
- これまで履歴の追跡に入れてきたファイルを追跡対象外にする
    ```bash
    git rm --cached ファイルパス1 ファイルパス2 ... # 複数同時に指定可能
    # --cached オプションなしだと、作業ディレクトリからも削除される
    ```
    > 下部ディレクトリも一緒に消す場合は `-r` オプションが必要らしい。

##### ステージされたファイルを履歴に残す：「コミット」

```bash
git commit -m スナップショットに関するメッセージ
```

`git commit` だけでも動きますが、メッセージを記録するためにデフォルトのエディタが起動するため、慣れていない場合はあらかじめ `-m` オプションでメッセージをつけておくと良いです。

#### 履歴の管理

`git add` + `git commit` でバージョン履歴をいくつか作成すると、コミットからなる履歴の列の情報が .git ディレクトリ以下に格納されています。過去のバージョンに戻るなどの操作をするには、この履歴情報を見ることができないといけません。

以下のようなことが可能です：

<img src="figs/git_log.drawio.svg" width=100%>

##### 今の状態を見る

基本は以下：

```bash
git status
```
> ```
> # ... 色々と情報が出る
> ```

表示される情報は以下のようなものです：
- 例1:（コミット直後）
    ```bash
    git status
    ```
    > ```
    > On branch main
    > nothing to commit, working tree clean
    > ```
- 例2:（test.txt というファイルをコミット後に編集した時）
    ```bash
    git status
    ```
    > ```
    > On branch main
    > Changes not staged for commit:
    >   (use "git add <file>..." to update what will be committed)
    >   (use "git restore <file>..." to discard changes in working directory)
    > 	modified:   test.txt
    > 
    > no changes added to commit (use "git add" and/or "git commit -a")
    > ```


##### 履歴の情報を見る

基本は以下です：
```bash
git log
```
> ```
> # コマンドラインが別モード（おそらく`less`コマンドでの表示）に移行
> # 上下キーで履歴情報を行ったり来たりできて、<q>キーで終了
> 
> # --- この塊が一つの履歴情報 ---
> commit [コミットごとに異なる番号]
> Author: [名前] <メールアドレス>
> Date:   yyyy-mm-dd hh:mm:ss +x
> 
>     コミット時のメッセージ
> # ---------------------------
> ```

なお、一番上のコミットの横に `(HEAD -> main)` あるいは `(HEAD -> master)` のような記載が見られると思いますが、これの意味は次節で説明します。

`commit [コミットごとに異なる番号]` の部分が、対象のスナップショットを表すIDです。デフォルトの `git log` だけだと簡易的な情報のみしか見えませんが、オプション引数を追加して実行すると色々な情報を見せてくれます：

|オプション|効果|
|--|--
|`--name-only`|コミットされたファイルパスも表示する
|`--stat`|コミットされたファイルパスと、各ファイルの変更分情報も表示
|`-p`|コミットされたファイルの実際のテキストとしての差分を表示する（長くなる可能性大）
|`--oneline`|デフォルト表示部分をより簡明に1行で表示

- 例1：（2回コミットした後）
    ```bash
    git log
    ```
    > ```
    > commit f98d4200057c8a91c14fb157fb5821200ccc7f5b (HEAD -> main)
    > Author: akinori tanaka <mail_address>
    > Date:   Tue Dec 2 15:06:49 2025 +0900
    > 
    >     2nd commit
    > 
    > commit ff1982b63a38d055ee77f70895bf893de3aa66e4
    > Author: akinori tanaka <mail_address>
    > Date:   Tue Dec 2 15:02:19 2025 +0900
    > 
    >     1st commit
    > 
    > ```
- 例2：（オプションをつける）
    ```bash
    git log --stat # 各コミット時にどのようなファイルがどれだけ変更されたか表示
    ```
    > ```
    > commit f98d4200057c8a91c14fb157fb5821200ccc7f5b (HEAD -> main)
    > Author: akinori tanaka <mail_address>
    > Date:   Tue Dec 2 15:06:49 2025 +0900
    > 
    >     2nd commit
    > 
    >  test.txt | 1 +
    >  1 file changed, 1 insertion(+)
    > 
    > commit ff1982b63a38d055ee77f70895bf893de3aa66e4
    > Author: akinori tanaka <mail_address>
    > Date:   Tue Dec 2 15:02:19 2025 +0900
    > 
    >     1st commit
    > 
    >  hoge.txt | 0
    >  test.txt | 0
    >  2 files changed, 0 insertions(+), 0 deletions(-)
    > ```

$\blacksquare$ **練習問題3:** 適当な管理対象ディレクトリにて、

```
管理対象ディレクトリ
├── fuga.txt      # 空でOK
└── hoge_dir
    └── hoge.txt  # 空でOK
```
というワーキングツリーを作り、
1. `.txt` ファイルを全てコミットしてみてください。
2. いずれかの `.txt` ファイルに内容を書き込み、改めてそれをコミットしてみてください。
3. ここまでのコミット履歴を確認してください。

> [!TIP]
> <details>
> <summary>解答例</summary>
> 
> 管理対象ディレクトリを作り、入って、`.git` を作ります：
> ```bash
> mkdir ~/exercise3
> cd ~/exercise3
> git init
> ```
> > ```
> > Initialized empty Git repository in /home/ユーザー名/exercise3/.git/
> > ```
> 次に問題にあるワーキングツリーを作ります：
> ```bash
> mkdir hoge_dir
> touch hoge_dir/hoge.txt fuga.txt
> ```
> これで作れました。あとはこれをステージして、コミットです：
> ```bash
> git add hoge_dir/hoge.txt fuga.txt
> git commit -m "1st commit"
> ```
> > ```
> > [master (root-commit) d195fc7] 1st commit
> >  2 files changed, 0 insertions(+), 0 deletions(-)
> >  create mode 100644 fuga.txt
> >  create mode 100644 hoge_dir/hoge.txt
> > ```
> ここで、名前とメールアドレスが登録されていないとエラーが出ます。
> 
> 次に "fuga.txt" を編集してコミットしてみます。何らかの方法で編集したのち、以下でOK。
> ```bash
> git add fuga.txt
> git commit -m "2nd commit"
> ```
> >```
> >[master cf8db0d] 2nd commit
> > 1 file changed, 1 insertion(+)
> >```
> メッセージで「1つのファイルが変更されました、1行追加、と書かれているのがわかります。最後に二つのコミット履歴を表示します。
> ```bash
> git log
> ```
> > ```
> > commit cf8db0d6ac87b3aadda5b8f3866d4bec6a7222df (HEAD -> master)
> > Author: test_user <test_address>
> > Date:   Tue Dec 16 00:30:25 2025 +0000
> > 
> >     2nd commit
> > 
> > commit d195fc7660f71e88bb16515feccc2856526b4252
> > Author: test_user <test_address>
> > Date:   Tue Dec 16 00:25:58 2025 +0000
> > 
> >     1st commit
> > ```
> なお、デフォルトの `git log` だとコミット時の `-m` オプションの後のメッセージのみ表示ですが、例えば `--stat` オプションをつけると：
> ```bash
> git log --stat
> ```
> > ```
> > commit cf8db0d6ac87b3aadda5b8f3866d4bec6a7222df (HEAD -> master)
> > Author: test_user <test_address>
> > Date:   Tue Dec 16 00:30:25 2025 +0000
> > 
> >     2nd commit
> > 
> >  fuga.txt | 1 +
> >  1 file changed, 1 insertion(+)
> > 
> > commit d195fc7660f71e88bb16515feccc2856526b4252
> > Author: test_user <test_address>
> > Date:   Tue Dec 16 00:25:58 2025 +0000
> > 
> >     1st commit
> > 
> >  fuga.txt          | 0
> >  hoge_dir/hoge.txt | 0
> >  2 files changed, 0 insertions(+), 0 deletions(-)
> > ```
> のように、どのような変更があったかまでわかります。
> </details>

$\blacksquare$ **練習問題4:** 練習問題3のワーキングツリーで
1. 最新の状態で `git status` を実行
2. 適当な `.txt`ファイル（例えば "fuga.txt"） を編集したのち `git status` を実行
3. 編集したファイルをステージに上げたのち `git status` を実行 
4. 3でステージに上げたファイルをステージから下げたのち `git status` を実行
5. 編集したファイルをステージに上げ、コミットしたのち `git status` を実行

して各段階の `git status` でどのような表示が出るか確認してみてください。
> [!TIP]
> <details>
> <summary>解答例</summary>
> 
> 
> 1. 同様のディレクトリで続けます。最新状態だと以下のようなメッセージが出ます：
>     ```bash
>     git status
>     ```
>     > ```
>     > On branch master
>     > nothing to commit, working tree clean
>     > ```
> 2. 編集した後ではこれが以下のように（ステージするにはこうしてね、というメッセージの表示に）変わるはずです：
>     ```bash
>     git status
>     ```
>     > ```
>     > On branch master
>     > Changes not staged for commit:
>     >   (use "git add <file>..." to update what will be committed)
>     >   (use "git restore <file>..." to discard changes in working directory)
>     >         modified:   fuga.txt
>     > 
>     > no changes added to commit (use "git add" and/or "git commit -a")
>     > ```
> 3. ステージに上げたが、コミットしていない状態を作って status をみると以下のように（ステージされたファイルをステージから下ろすコマンドと、ステージされたファイルの表示と）なります：
>     ```bash
>     git add fuga.txt # コミットはしていない
>     git status
>     ```
>     > ```
>     > On branch master
>     > Changes to be committed:
>     >   (use "git restore --staged <file>..." to unstage)
>     >         modified:   fuga.txt
>     > 
>     > ```
> 4. 上のコマンドでステージを上げる前に戻せます：
>     ```bash
>     git restore --staged fuga.txt
>     git status
>     ```
>     > ```
>     > On branch master
>     > Changes not staged for commit:
>     >   (use "git add <file>..." to update what will be committed)
>     >   (use "git restore <file>..." to discard changes in working directory)
>     >         modified:   fuga.txt
>     > 
>     > no changes added to commit (use "git add" and/or "git commit -a")
>     > ```
> 5. ステージし、コミットしたあとは1の表示に戻ります：
>     ```bash
>     git add fuga.txt
>     git commit -m "added"
>     ```
>     > ```
>     > [master 6738117] added
>     >  1 file changed, 1 insertion(+)
>     > ```
>     ```bash
>     git status
>     ```
>     > ```
>     > On branch master
>     > nothing to commit, working tree clean
>     > ```
> 
> </details>

$\blacksquare$ **練習問題5:** 練習問題3のワーキングツリーで、適当な `.txt` ファイルを追跡対象外にしてください。
> [!TIP]
> <details>
> <summary>解答例</summary>
> 
> 
> とりあえず再び "fuga.txt" を編集したとして
> 
> ```bash
> cat fuga.txt 
> ```
> > ```
> > This is changed.
> > ```
> という内容とします。コミットはしていません。この状態でstatusをみると：
> 
> ```bash
> git status
> ```
> > ```
> > On branch master
> > Changes not staged for commit:
> >   (use "git add <file>..." to update what will be committed)
> >   (use "git restore <file>..." to discard changes in working directory)
> >         modified:   fuga.txt
> > 
> > no changes added to commit (use "git add" and/or "git commit -a")
> > ```
> 
> となって、ステージしてコミットするためのコマンドが出ますが、あえてここで対象のファイルを以後gitの追跡から外したい（変更があっても `Changes not staged for commit` に表示されないようにする）場合は以下です
> 
> ```bash
> git rm --cached fuga.txt 
> ```
> > ```
> > rm 'fuga.txt'
> > ```
> 
> なお、これだけではまだコミットしていないため、statusをみると`deleted:    fuga.txt` という表示が `Changes to be committed:` の部分に表示されています。
> 
> ```bash
> git status
> ```
> > ```
> > On branch master
> > Changes to be committed:
> >   (use "git restore --staged <file>..." to unstage)
> >         deleted:    fuga.txt
> > 
> > Untracked files:
> >   (use "git add <file>..." to include in what will be committed)
> >         fuga.txt
> > 
> > ```
> 
> この状態でコミットすると、「"fuga.txt" を追跡しないようにした」という履歴が残り、以後それが適用されます：
> 
> ```bash
> git commit -m "fuga is removed"
> ```
> > ```
> > [master 86ecb56] fuga is removed
> >  1 file changed, 1 deletion(-)
> >  delete mode 100644 fuga.txt
> > ```
> 
> 最後の状態で status をみると：
> 
> ```bash
> git status
> ```
> > ```
> > On branch master
> > Untracked files:
> >   (use "git add <file>..." to include in what will be committed)
> >         fuga.txt
> > 
> > nothing added to commit but untracked files present (use "git add" to track)
> > ```
> となって、`Untracked files` があるよ、という表示だけになりました。
> 
> </details>


### バージョンの「枝」

ここまでで、シンプルなバージョン履歴の残し方を説明してきました。適当なIDのバージョンに戻す前に、バージョン履歴が必ずしも直線的ではなく、枝分かれさせられることを説明します：

<img src="figs/git_branch.drawio.svg" width=100%>

#### Gitの参照（ポインタ）

枝分かれしても、コミットの際のIDがあるため、原理的には全ての履歴を辿ることができます。しかし、
- 人間が作業する際は「枝分かれさせた意義」で名前をつけた方が分かりやすいでしょう。
- また、「自分が今どちらの枝にいるか？」というのも重要でしょう。

これらの概念がコミット履歴（バージョン枝）にはすでに書き込まれています。それが上で説明を省いた `(HEAD -> main)`/`(HEAD -> master)` の部分です。

##### 枝分かれさせた意義を示す：ブランチ名

`(HEAD -> main)` の表示の `main` に当たる部分を**ブランチ名**と言います。`main` ブランチは `git init` するとできるデフォルトのブランチ名です。ブランチ名は
- そのブランチがどれを最新コミットとみなしているかのポインタ

となっています。下の図でいう「緑色」の箱のイメージです。

> `master` という名前がデフォルトブランチ名だったのは少し古いバージョンの `git` です。Google Cloud Shell のデフォルトの `git` は少し古いかもしれません。

##### 自分が今どちらの枝にいるかを示す：HEAD

`(HEAD -> main)` の表示の `HEAD` に当たる部分は特殊なポインタで、
- （基本的には）ブランチ名を指し示すポインタ

です。これは「自分がどのブランチにいるか」を意味します。コミットの際は、この `HEAD` が指し示すブランチが成長していくことになります。下の図でいう「青色菱形の箱」のイメージです。


<img src="figs/git_branch2.drawio.svg" width=100%>

##### HEADの移動

```bash
git switch [ブランチ名]
```

で`HEAD`が指す対象を、（まだ作成法を説明していませんが）すでに存在する別のブランチに移動できます。移動前に現在のブランチでコミットしていなければコミットしてください。なお、それに伴って管理ディレクトリ中のファイルの様相が変更先のブランチの最新コミットのものに変わります。

<img src="figs/git_branch3.drawio.svg" width=100%>


##### ブランチの作成

実は新しいブランチ作成もこのコマンドに `-c` オプションをつけてできてしまいます：

```bash
git switch -c [新しいブランチ名]
```

枝分かれはデフォルトでは現在の `HEAD` のしめすコミットからとなります。

<img src="figs/git_branch4.drawio.svg" width=100%>

上の図のように、新しいブランチ `new_branch` を作成したのちコミットすると、`new_branch` の履歴が成長していくことになりますが、`main` はそのままです。最後の状態で `git switch main` すると、`main` が指し示す履歴まで戻ってこられるというわけです。

> - 本来のブランチ作成コマンドは `git branch` ですが、これは作成するだけで、`HEAD` が移動しません。したがって、`git branch` でブランチ作成したのち、`git switch` で `HEAD` を移す、という手順を踏むことになります。
> - ブランチを作成、そちらで作業を進めることを **ブランチを切る** というようです。また、ブランチを移動することを **checkout** と言う場合もあります。

##### detached HEAD

`HEAD` は基本はブランチ名を指し示すのですが、直接コミットを指し示すこともできます。この状態を detached HEAD （ブランチ名から切り離されたHEAD）と言います。detached HEAD は過去の任意のコミットに戻る際に使用できますが、その名前の通り「**通常のHEADの運用からは外れた使い方**」なので注意が必要です。コマンドは `--detach` オプション＋`コミットID` です：

```bash
git switch --detach [コミットID]
```

`[コミットID]` は `git log --oneline` で表示される省略IDでもOKです。

<img src="figs/git_branch5.drawio.svg" width=100%>


HEADの位置を変えると作業ディレクトリ中の管理ファイルの内容がそのコミット時のものに戻るので、過去コミットでのファイルの様子を見たい場合などに有用ですが、この状態のままコミットすると、ブランチ名がないため、別のブランチに移った後、戻ってくるのが少し難しくなります。
> 不可能というわけではありませんが、そのようにして作成したコミット履歴は消失する恐れがあります：[git-pro本参照](https://git-scm.com/book/ja/v2/Git%E3%81%AE%E5%86%85%E5%81%B4-%E3%83%A1%E3%83%B3%E3%83%86%E3%83%8A%E3%83%B3%E3%82%B9%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E3%83%AA%E3%82%AB%E3%83%90%E3%83%AA)

過去コミットに戻ってそこから作業再開したい場合は、`git switch -c [新しいブランチ名]` で、そのコミットから新しくブランチを切るのがお作法となります。


$\blacksquare$ **練習問題6:** 以下のコマンドを実行してください（userとmail登録後）：

```bash
mkdir ~/exercise6
cd ~/exercise6
git init 
touch test.txt
git add test.txt; git commit -m "1st commit"
git switch -c A
echo "# This is the context in A branch." > test.txt
git add test.txt; git commit -m "2nd commit in A."
git switch master # or main
echo "$ This is the context in main branch." > test.txt
git add test.txt; git commit -m "2nd commit in main."
```

この時のコミット履歴の状態を（以下で解説するコマンドで）可視化すると：
```bash
git log --oneline --graph --decorate --all
```
> ```
> * dcd85b2 (A) 2nd commit in A.
> | * 6605633 (HEAD -> master) 2nd commit in main.
> |/  
> * 3fd0bdb 1st commit
> ```
このようになっています。この例だと `A` というブランチ と `master` ブランチがあります。

1. 今の状態（`HEAD -> master`）で "test.txt" の内容を確認してください。
2. 1の後、`git switch A` し、 "test.txt" の内容を確認し、1と比べてどうなっているか確認してください。
3. 2の後、`git switch master` し、"test.txt" の内容を確認し、1や2と比べてどうなっているか確認してください。

> [!TIP]
> <details>
> <summary>解答例</summary>
> 
> "test.txt" の内容が `A` ブランチ と `master` ブランチで異なるのですが、それが観察できるはずです。例えば `HEAD -> master` の状態では
> 
> ```bash
> cat test.txt
> ```
> > ```
> > $ This is the context in main branch.
> > ```
> 
> ブランチを変えてみると：
> ```bash
> git switch A
> ```
> > ```
> > Switched to branch 'A'
> > ```
> ```bash
> cat test.txt
> ```
> > ```
> > # This is the context in A branch.
> > ```
> 確かに変わっています。また元に戻すと：
> ```bash
> git switch master
> ```
> > ```
> > Switched to branch 'master'
> > ```
> ```bash
> cat test.txt
> ```
> > ```
> > $ This is the context in main branch.
> > ```
> となるはずです。
> 
> </details>

$\blacksquare$ **練習問題7:** 自分でブランチを切ってみてください。
> [!TIP]
> <details>
> <summary>解答例</summary>
> 
> ディレクトリを新たに作って適当にコミット履歴を作ります：
> ```bash
> mkdir ~/exercise7
> cd ~/exercise7
> git init
> touch test.txt; git add test.txt; git commit -m "1st commit"
> echo "This is test." > test.txt; git add test.txt; git commit -m "2nd commit"
> ```
> ここいらでブランチを切ってみましょう：
> ```bash
> git switch -c new_branch
> echo "This is additional sentence." >> test.txt; git add test.txt; git commit -m "commit in new branch"
> ```
> この状態でコミット履歴を見てみますと：
> ```bash
> git log --oneline --graph --decorate --all
> ```
> > ```
> > * fcbbba9 (HEAD -> new_branch) commit in new branch
> > * 03bc465 (master) 1st commit
> > ```
> こんな感じで、`new_branch` の履歴が進みました。
> 
> なお、ここで `master` に戻ってコミットすると、枝分かれします：
> 
> ```bash
> git switch master
> echo "New line" > test.txt; git add test.txt; git commit -m "2nd commit"
> git log --oneline --graph --decorate --all
> ```
> > ```
> > * be55ecf (HEAD -> master) 2nd commit
> > | * fcbbba9 (new_branch) commit in new branch
> > |/  
> > * 03bc465 1st commit
> > ```
> </details>



#### ブランチの管理

ここまでの内容で、コミット履歴の枝を（detached HEADは難しいですが）自由自在に行き交うことができるようになっているはずです。ですが、枝が増えすぎるとごちゃごちゃしてきます。一応、gitの想定しているブランチの使用方法は、
- `main`ブランチ を安定バージョンとしつつ
- 新たな機能などを追加するために別にブランチを切る
- 新たな機能が完成したら、それを `main`ブランチに統合し、開発ブランチは消す

というもののようです：[git-pro本参照](https://git-scm.com/book/ja/v2/Git-%e3%81%ae%e3%83%96%e3%83%a9%e3%83%b3%e3%83%81%e6%a9%9f%e8%83%bd-%e3%83%96%e3%83%a9%e3%83%b3%e3%83%81%e3%81%a7%e3%81%ae%e4%bd%9c%e6%a5%ad%e3%81%ae%e6%b5%81%e3%82%8c)

そのような使い方のためには、ブランチを切るだけではなく、どんなブランチが存在しているか確認したり、それらを統合したり、消したりできないといけません。ここではそのやり方を説明します。

##### 存在するブランチを見る

これには幾らかのやり方があります
- ブランチ名一覧を表示：
    ```bash
    git branch -v
    ```
    > ```
    > # 実際は色付きでもう少し見やすいです
    > # `*` がついているのが HEADが指しているものです
    > * ブランチ1       コミットID1 コミットメッセージ1
    >   ブランチ2       コミットID2 コミットメッセージ2
    >   ...
    > ```
- 履歴の枝＋ブランチ情報をAAで可視化する：
    ```bash
    git log --oneline --graph --decorate --all
    ```
    > ```
    > # 実際は色付きでもう少し見やすいです
    > * コミットID3 (HEAD -> ブランチ1) コミットメッセージ3
    > * コミットID2 コミットメッセージ2
    > | * コミットID3' (ブランチ2) コミットメッセージ3'
    > | * コミットID2' コミットメッセージ2'
    > |/  
    > * コミットID1 コミットメッセージ1
    > ```

##### ブランチAにブランチBを結合する

ブランチAにcheckoutしたのち、`git merge ブランチB` で Bの変更をAに取り込むことができます：

```bash
git switch ブランチA  # これで (HEAD -> ブランチA) としておく
git merge ブランチB   # ブランチA に ブランチB を結合
```

例：`main` に `branch1` を結合

<img src="figs/git_branch6.drawio.svg" width=100%>

なお、マージ完了した場合にコミットのグラフを見るとちょうど図で書いたような片方がもう片方に結合されたような表示になります。また、**グラフの意味的には追加でコミットが必要**なことに注意してください。マージが機械的に（自動で）完了する場合は `git merge` でコミットまで自動で行われますが、以下で説明するようなファイルの競合（コンフリクト）が起こった場合はユーザーが手でコミットまで行います。

###### conflict が起こったら

マージをすると二つのブランチの最新ファイルが自動で結合されますが、同一パスのファイルを変更していた場合は自動では解決できないコンフリクトが生じ、以下のようなメッセージが出る場合があります：
```
Auto-merging ファイル名
CONFLICT (content): Merge conflict in ファイル名
Automatic merge failed; fix conflicts and then commit the result.
```

この場合でも `git merge` コマンド自体は（部分的に）成功しているので大丈夫です。ただしマージ自体は完了していない状態で、以下の作業が必要です。

この状態では、コンフリクトが起こったワーキングツリー上のファイルが「どちらの変更を採用しますか？」という内容で上書きされます。例えば、以下の状況（`...`部分は複数行にまたがって同じ内容）だった場合：

<table>
<thead>
<tr>
<th>ブランチA（こちらにマージする）のファイルの内容</th>
<th>ブランチBのファイルの内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>

```
... 
This is test.
... 
```

</td>
<td>

```
... 
Hoge is fuga.
... 
```

</td>
</tr>
<tr>
<td><code>git merge ブランチB</code>を実行後コンフリクトが発生した後</td>
<td></td>
</tr>
<tr>
<td>

```
... 
<<<<<<< HEAD
This is test.   # 自分が今いるブランチ A の内容
======= 
Hoge is fuga.   # マージしようとしているブランチ B の内容
>>>>>>> ブランチB
... 
```

</td>
<td>


</td>
</tr>
</tbody>
</table>

のように元のファイルが変更を受けます。ここで `<<<<<<< HEAD` や `=======` や `>>>>>>> ブランチB` は単なるマーカーで、編集の際に消してしまって大丈夫です。コンフリクトが発生した行ごとに上のような変更を生じるので、手動でどちらを採用するか編集します。ファイルの編集が済んだら、**対象のファイルをコミットすることでマージが完了します**。この際のコミットメッセージには典型的には「コンフリクトをどのように解決したか」を書きます。



##### ブランチを消去する

```bash
git branch -d ブランチ名
```

これをすると、単に指定したブランチのポインタ（図で対象の緑色の箱）がなくなるだけです。ですので、マージした後にマージされたブランチを消しても何の問題もありません。ただし、マージしていないブランチを消すと、そちらのコミット履歴へのアクセスが悪くなるため、注意してください。（detached HEAD状態でコミットしたのと似た状況になります。）


##### リベース

マージに似た操作でリベースというのもありますが、扱いがやや難しい（のと私もよくわかっていない）ので省略します。誰か正しい使い方を教えてください。

### やり直しのイロハ

さて、バージョン管理の最大の強みは当然ながら「過去のバージョンに戻れる」ことです。間違ってもやり直せます。ですが、やり直す方法がいろいろあるため、ここではケースバーケースで「やり直し方」を解説します。すべてのケースを網羅することはできないので、ここに載っているケース以外に遭遇した場合は生成AIに聞く＋ネット検索するなどして見てください。

#### コミット単位で戻る

これまで説明してきたやり方で、すでにコミット単位ではやり直しが可能になっています。具体的には
1. `git log` などで戻りたいコミットを見つける
2. `git switch コミットID` でそこに戻る（detached HEAD）
3. `git switch -c ブランチ名` でブランチを切って、そのコミットからやり直す

です。2と3はじつは1度にできて：
```bash
git switch -c ブランチ名 コミットID
```
で良いようです。他の過去改変に比べ、このやり方は最も安全です。

#### コミットしていない作業ディレクトリを最後のコミット状態に戻す

- 特定の（ステージしていない）ファイルを最後のコミット時の状態に戻す
    ```bash
    git restore ファイルパス1 ファイルパス2 ...
    ```
- ステージしていないコミット対象のファイルをすべてコミット時の状態に戻す
    ```bash
    git restore .
    ```
- ステージしたファイルをステージから下ろす
    ```bash
    git restore --staged ファイルパス1 ファイルパス2 ...
    ```

#### 過去改変

その他、**コミット履歴を変更する＝過去改変する**コマンドも存在しますが、これらのコマンドを使うと混乱の元なので、ここでは解説しません。コラムに少しこの周辺のことを書いたので参考にしてみてください。


$\blacksquare$ **練習問題８:** マージの練習（コンフリクトなし）

```bash
mkdir ~/exercise8; cd ~/exercise8
git init
touch test.txt hoge.txt
git add test.txt hoge.txt; git commit -m "1st commit"
git switch -c branch1 
echo "This is hoge." > hoge.txt
git add hoge.txt; git commit -m "commit in branch1"
git switch master
git log --oneline --graph --decorate --all
```
> ```
> # 色々出たのち、最後にコミット履歴のツリーが出る：
> * c87da28 (branch1) commit in branch1
> * 95674b8 (HEAD -> master) 1st commit
> ```
この状態（`HEAD -> master`）で、"test.txt" を適当に編集してコミットし、`branch1` を `master` にマージしてください。

> [!TIP]
> <details >
> <summary>解答例</summary>
> 
> 適当に `master` ブランチで "test.txt" を編集します:
> ```bash
> echo aaa > test.txt 
> ```
> この後、
> ```bash
> git add test.txt; git commit -m "2nd commit"
> ```
> > ```
> > [master a28ebaa] 2nd commit
> >  1 file changed, 1 insertion(+)
> > ```
> 後にマージコマンド：
> ```bash
> git merge branch1 
> ```
> > ```
> > # nanoか何かのエディタが起動するかも。
> > # その場合はデフォルトメッセージがすでに書かれているので、エディタを終了でOK
> > # 以下のようなメッセージが出たら成功です：
> > Merge made by the 'ort' strategy.
> >  hoge.txt | 1 +
> >  1 file changed, 1 insertion(+)
> > ```
> エディタが起動するのは、実は**この場合はコミットまで自動で行われている**からです。なお、この状態でログを見ると：
> ```bash
> git log --oneline --graph --decorate --all
> ```
> > ```
> > *   d2ce291 (HEAD -> master) Merge branch 'branch1'
> > |\  
> > | * c87da28 (branch1) commit in branch1
> > * | a28ebaa 2nd commit
> > |/  
> > * 95674b8 1st commit
> > ```
> となって、説明の際に用いた図のようになります。
> </details>

$\blacksquare$ **練習問題９:** マージの練習（コンフリクトあり） 

```bash
mkdir ~/exercise9; cd ~/exercise9
git init
touch test.txt 
git add test.txt; git commit -m "1st commit"
git switch -c branch1 
echo "This is hoge." > test.txt
git add test.txt; git commit -m "commit in branch1"
git switch master
git log --oneline --graph --decorate --all
```
> ```
> # 色々出たのち、最後にコミット履歴のツリーが出る：
> * 218e180 (branch1) commit in branch1
> * a1acdbb (HEAD -> master) 1st commit
> ```
この状態（`HEAD -> master`）で、"test.txt" を適当に編集してコミットし、`branch1` を `master` にマージしてください。

> [!TIP]
> <details>
> <summary>解答例</summary>
> 
> 適当に `master` ブランチで編集します：
> ```bash
> echo aaa > test.txt
> ```
> この後、コミットし：
> ```bash
> git add test.txt; git commit -m "2nd commit"
> ```
> > ```
> > [master 46b629a] 2nd commit
> >  1 file changed, 1 insertion(+)
> > ```
> 後にマージコマンドを実行すると、おそらく以下のメッセージが出るはずです：
> ```bash
> git merge branch1 
> ```
> > ```
> > Auto-merging test.txt
> > CONFLICT (content): Merge conflict in test.txt
> > Automatic merge failed; fix conflicts and then commit the result.
> > ```
> 自動マージが失敗したので自分でコンフリクトを解決しろと言われます。実際、対象のファイルを見てみると：
> ```bash
> cat test.txt
> ```
> > ```
> > <<<<<<< HEAD
> > aaa
> > =======
> > This is hoge.
> > >>>>>>> branch1
> > ```
> のようになっているので、これを編集します。今回は例えば
> ```bash
> cat test.txt
> ```
> > ```
> > aaa
> > This is hoge.
> > ```
> となるようにしました。これで普通にコミットできます:
> ```bash
> git add test.txt; git commit -m "Merge 'branch1' and conflict solved."
> ```
> > ```
> > [master eb1aa7d] Merge 'branch1' and conflict solved.
> > ```
> これでログを見てみると、練習問題8と同様のグラフとなります:
> ```bash
> git log --oneline --graph --decorate --all
> ```
> > ```
> > *   eb1aa7d (HEAD -> master) Merge 'branch1' and conflict solved.
> > |\  
> > | * 218e180 (branch1) commit in branch1
> > * | 46b629a 2nd commit
> > |/  
> > * a1acdbb 1st commit
> > ```
> </details>


### ホスティングサーバーと繋げる

ここまでは個人使用の際の `git` コマンドを説明してきました。これだけでも便利なのですが、
- 手元のPCがクラッシュしてしまうことを考えて、バックアップをどこかに置いておきたい
- 多人数で同じディレクトリを共有/編集したい場合がある（論文執筆など）

ということがあるでしょう。このような時に便利なのが GitHub などのホスティングサービスを使うことです。ホスティングサービスを使うと、コミット履歴をそのサーバー上にバックアップとして取ることができ、サーバーをハブとして多人数間での共有も可能になります：

<img src="figs/git_remote.drawio.svg" width=100%>

図にあるように、この使用法では新たに赤色で示している
- `origin/ブランチ名`（ホストの `.git` でのブランチ）
- `origin/HEAD`（ホストの `.git` でのHEAD）

というポインタが追加されます。これはホスト側の履歴を管理するためのもので、**ユーザーが直接触るものではありません**。これらのホスト側のポインタは、手元に同期した際にも見えるものとなりますが、**個々のユーザーの作業は今まで通り（originのついていない）`ブランチ名`（図の緑色）や `HEAD`（図の青色） で行います**。 

> [!CAUTION]
> 図の中ではホスト側に置かれたポインタも `origin/main` や `origin/HEAD` などと描いていますが、実際はホスト側のポインタでは `origin/` はついておらず、同じく `main`、`HEAD` という名前のポインタらしいです。`origin/`がつくのはローカル側からホストのポインタとローカルのポインタを区別するためのもののようです。ですが、以下わかりよさを優先して絵の中でホストのポインタにも `origin/`をつけることにします。

ホストサーバーに存在する履歴とは `git pull` で同期でき、ローカルの変更は `git push` でホストに反映させることができます。この二つのコマンドで各自がホストとローカルの内容を同期して、プロジェクトを進めてゆきます。競合が起こった場合は各自がまずローカル環境で競合を解決し、その履歴をまたホストに同期するという形をとります。なので、原理的に複数名で作業していても自動的な上書きが起こりづらく、ほぼ確実に人の手を介した競合解決が行われる仕組みです。

#### ホスティングサービスと接続の設定

以下、前回の [ssh接続](2-3.md) の説明でも紹介したホスティングサービスです。同期の際のプロトコルは 

- https + Personal Access Token (PAT)によるもの
- ssh（公開鍵認証）によるもの

の2種類があるようです。後者が1度登録すれば簡単で堅牢なのでおすすめです。以下、ssh接続を前提とします。

##### GitHub 

最大手のgitホスティングサービスで、他にもホームページを作ることができたり、色々な機能があります。猫のマークで有名。2018年からMicrosoft傘下。

登録方法：https://github.co.jp/ から登録可能です。基本的に無料で使えるはずです。

#### Bitbucket

GitHubほど知られていない気がしますが、GitHubに無料のプライベートリポジトリがなかったときに私は使い始めました。今でも使っています。Atlassian傘下。

登録方法：https://bitbucket.org/product/ja の 「無料で入手する」から登録できるはず。


#### リポジトリとその同期方法

これらのサービスはWebブラウザ上でログインして使います。ログインすると自分に与えられたスペース上でバージョン管理のためのプロジェクトページを作成できるようになります。サーバー上では `.git` ディレクトリに対応する部分（**リポジトリ**）しか存在しません。

##### 新規リポジトリの作成/削除

基本的にはWebブラウザ上で各サービスにログインし、そこから
- GitHubの場合：
    - 自分のアカウントのトップページから右上の `+` マークをクリックし、新規リポジトリ（New repository）をクリックすると、リポジトリ作成のフォームに飛ばされる。
    - 削除したいリポジトリのトップページから Settings のタブをクリック、そのリンク先の一番下に `Danger Zone` という見出しがあり、その中に Delete this repository というのがあるのでそれを選ぶ。色々（パスワードなど）入力して消す。
- Bitbucketの場合：
    - 自分のアカウントのトップページから上の `create` マークをクリックし、リポジトリ（Repository）をクリックすると、リポジトリ作成のフォームに飛ばされる。
    - 削除したいリポジトリのトップページから Repository settings のタブをクリック、Repository details を選び、右上の Manage repository をクリックすると delete メニューが出るので、あとはそれに従う。

この段階でホスト側に、作業ディレクトリを持たない `.git` の中身に相当する管理領域が作成されるイメージです。作成後に手元のPCにこのリポジトリを持ってきます。なお、どちらも **public** と **private** が選択できますが、以下の差があります：
- **public**
    - 誰でも（URL などの）場所がわかれば、リポジトリの内容や履歴をダウンロード・閲覧できる。
    - ただし、履歴をアップロードできるのは書き込み権限を持つユーザーのみ。
    - GitHubの場合は別のユーザーが自身のアカウントのリポジトリとしてコピーする（**フォーク** と言います）ことが可能で、その場合はフォークした段階から独立した履歴がフォークしたユーザーのリポジトリとして機能する。
        > なお、GitHubなどでは、フォークしたリポジトリのブランチを元のリポジトリに対して比較し、その差分を元リポジトリに マージしてもらうことを依頼する **プルリクエスト** という仕組みがあります。
- **private**
    - 自分あるいは招待したユーザーだけが履歴をダウンロード/アップロードできる。
    - それ以外のユーザーは、リポジトリの内容を閲覧したり履歴を操作することはできない。

##### sshで通信する場合

"~/.ssh/config" に GitHub / Bitbucket の情報を追加しておいてください：

```
Host github.com
        Hostname github.com
        User git 
        IdentityFile ~/.ssh/GitHubに登録した秘密鍵

Host bitbucket.org
        HostName bitbucket.org
        User git
        IdentityFile ~/.ssh/bitbucketに登録した秘密鍵
```

##### リポジトリを手元に複製

基本的には以下でOKです。

```bash
git clone [リポジトリのURL]
```

sshの公開鍵認証を用いる場合、ここで秘密鍵のパスキーの入力が求められます（たぶん）。

デフォルトではこのコマンドを実行した**カレントディレクトリ直下**にリポジトリのディレクトリが作成され、その中にホストの履歴を格納した `.git` と、`origin/HEAD` で管理対象になっている実際のファイルなどが入ります。`[リポジトリのURL]` の後にパスを指定することも可能です。

なお、`[リポジトリのURL]` 部分は以下のようにして取得します：
- GitHub
    - 対象のリポジトリのトップページの `< > code` と書かれたボタンをクリックすると出てくる。いくつかバリエーションがありますが、今回はsshを選んでください。
- Bitbucket
    - 対象のリポジトリのトップページの `クローンの作成` と書かれたボタンをクリックすると出てくる。いくつかバリエーションがありますが、今回はsshを選んでください。

##### ホストの履歴を手元に反映

クローンした直後ではなく、その後ホストに変更が発生した場合の同期方法です。やり方が二つあります。イメージ的にはソフトな同期とハードな同期です。
- ソフトな同期：作業ディレクトリの内容は変えず、コミット履歴とポインタだけダウンロード
    ```bash
    git fetch
    ```
    <img src="figs/git_fetch.drawio.svg" width=100%>
- ハードな同期：
    ```bash
    git pull
    ```
    これは実は以下のコマンドと同じ意味です：
    ```bash
    git fetch
    git merge origin/ブランチ名 # この時：HEAD -> ブランチ名
    ```
    <img src="figs/git_pull.drawio.svg" width=100%>

sshの公開鍵認証を用いる場合、ここで秘密鍵のパスキーの入力が求められます。基本的には後者のコマンドで、作業中のファイルも同期するので問題ないと思います。手元のファイルは変更したくない場合に前者の方法を用います。


##### 手元の履歴をホストに反映

クローン後に手元のコミット履歴をホストに反映させるコマンドです。

```bash
git push
```

sshの公開鍵認証を用いる場合、ここで秘密鍵のパスキーの入力が求められます。

このコマンドでは以下のことが起きます：

<img src="figs/git_push.drawio.svg" width=100%>

- ホストと手元の `origin/HEAD -> origin/ブランチ名` が ローカルの `HAED -> ブランチ名` と同期される
- なお、デフォルトでは `main` ブランチしかないが、別のブランチにHEADを移してpushすることもできる（後述）

###### ホストが変更されている場合

もし共同作業している別のユーザーがいて、そのユーザーが先に履歴を変更していた場合、コマンドは失敗します：

<img src="figs/git_push2.drawio.svg" width=100%>

その際はまず `git pull` でホスト履歴と同期が必要です。その際、場合によっては競合が起こりますが、これは**ブランチのマージの際の競合と全く同じようにして解決します**（`git pull` は `git fetch` + `git merge origin/ブランチ名` なのでした）：

<img src="figs/git_push3.drawio.svg" width=100%>

###### 新しいブランチをホスト側に作成する

デフォルトでは `HEAD -> main` での同期のみオンになっており、それ以外のブランチにいる場合：`HEAD -> main以外のブランチ名` は、`git push` しても
```bash
git push
```
> ```
> fatal: The current branch main以外のブランチ名 has no upstream branch.
> To push the current branch and set the remote as upstream, use
> 
>     git push --set-upstream origin main以外のブランチ名
> 
> To have this happen automatically for branches without a tracking
> upstream, see 'push.autoSetupRemote' in 'git help config'.
> ```

とエラーが出ます。このエラー中にある

```bash
git push --set-upstream origin main以外のブランチ名
```
とすると、ホスト上に `origin/main以外のブランチ名` というポインタが作成され、そちらにも履歴を記録できるようになります。また、ブラウザ上のUIでも各ブランチをスイッチできるようになります。別ブランチでもバックアップを取っていきたい場合に有用です。

###### ホストのブランチを削除

上のようにして作成したリモートブランチを削除するコマンドは

```bash
git push origin --delete main以外のブランチ名
```

です。このコマンドではローカルのブランチは残ります。


$\blacksquare$ **練習問題10:** （**sshの鍵設定が必要、Google Cloud Shellではなく、手元のPCからやることをおすすめします。**）GitHubあるいはBitbucketにプライベートリポジトリを作ってクローンし、
- コミット→pushしてみて結果が反映されているかチェック
- ブラウザから編集後コミット、その後手元にpullして編集が反映されているかチェック
- 手元とブラウザ両方で別の編集しコミット後、pushしようとするとエラーが起きるはずです（これは多人数で編集を行なった場合の仮想的な練習です。手元の編集を終えた際に普通はホスト側が進んでいるかどうかわからないので、pushしようとするはずです）。これを解決してください。
> [!TIP]
> <details>
> <summary>解答例</summary>
> 
> GitHubで適当な名前で空のプライベートリポジトリ：test を作ってみました。まずGitHubのssh用のurlでクローン：
> ```bash
> git clone git@github.com:AkinoriTanaka-phys/test.git
> ```
> > ```
> > Cloning into 'test'...
> > Enter passphrase for key '私のGitHubの鍵のパス': 
> > warning: You appear to have cloned an empty repository.
> > ```
> 何もないリポジトリなので「空だよ」と言われてますがここから作ります。念の為 `.git` があるか確認：
> ```bash
> cd test
> ls -a
> ```
> > ```
> > .       ..      .git
> > ```
> ありました。では適当なファイルを作成してコミットします：
> ```bash
> echo this is test! > test.txt
> git add test.txt
> git commit -m "1st commit"
> ```
> > ```
> > [main (root-commit) de9a8eb] 1st commit
> >  1 file changed, 1 insertion(+)
> >  create mode 100644 test.txt
> > ```
> ログを見ると、これが最初のようです：
> ```bash
> git log
> ```
> > ```
> > commit de9a8eb07e9ee8d1ef813165261733ce48f2fd4e (HEAD -> main)
> > Author: akinori tanaka <mail_address>
> > Date:   Wed Dec 17 14:03:17 2025 +0900
> > 
> >     1st commit
> > ```
> 
> 空で作ったからか、`origin/main` もないです。とりあえずpushしてみましょう：
> 
> ```bash
> git push
> ```
> > ```
> > Enter passphrase for key '私のGitHubの鍵のパス': 
> > Enumerating objects: 3, done.
> > Counting objects: 100% (3/3), done.
> > Writing objects: 100% (3/3), 225 bytes | 225.00 KiB/s, done.
> > Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
> > To github.com:AkinoriTanaka-phys/test.git
> >  * [new branch]      main -> main
> > ```
> 
> この状態でログを見てみると、`origin/main` のポインタが現れたことが確認できます:
> 
> ```bash
> git log
> ```
> > ```
> > commit de9a8eb07e9ee8d1ef813165261733ce48f2fd4e (HEAD -> main, origin/main)
> > Author: akinori tanaka <mail_address>
> > Date:   Wed Dec 17 14:03:17 2025 +0900
> > 
> >     1st commit
> > ```
> 
> 次にブラウザからリポジトリのトップページに行ってみると、新しくファイル "test.txt" ができていることが確認できます。次に、これをブラウザ上で編集します。右上のボタンでペンのマークがあるので、それをクリックすると編集からコミットまでできます。これは `origin/main` のコミット履歴が更新されることになります。内容は
> ```
> this is test!
> Added from online!!
> ```
> としました。コミット時には `Commit changes..` という緑色のボタンを押し、コミットメッセージを入力、mainブランチ（デフォルト）にチェックを入れます。その後、ローカルに戻り、pullしてみますと：
> 
> ```bash
> git pull
> ```
> > ```
> > Enter passphrase for key '私のGitHubの鍵のパス': 
> > remote: Enumerating objects: 5, done.
> > remote: Counting objects: 100% (5/5), done.
> > remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)
> > Unpacking objects: 100% (3/3), 938 bytes | 234.00 KiB/s, done.
> > From github.com:AkinoriTanaka-phys/test
> >    de9a8eb..81ccbe7  main       -> origin/main
> > Updating de9a8eb..81ccbe7
> > Fast-forward
> >  test.txt | 1 +
> >  1 file changed, 1 insertion(+)
> > ```
> となって、ローカルでも更新が行われたことがわかります。`git log` でも確認できますし、実際にファイルを見てみても良いです：
> ```bash
> cat test.txt
> ```
> > ```
> > this is test!
> > Added from online!!
> > ```
> 
> では最後に、手元とブラウザ、両方で別の編集を行なってpushしようとしてみましょう。
> 
> まずブラウザからファイルを以下のように変更しました：
> 
> ```
> From browser, hello!
> 
> this is test!
> Added from online!!
> ```
> 
> 手元は以下のように新たな行を追加しました：
> 
> ```
> From local, hello!
> 
> this is test!
> Added from online!!
> ```
> 
> この状態でコミット→pushしようとしてみます。まずコミットは成功します:
> 
> ```bash
> git add test.txt; git commit -m "2nd commit"
> ```
> > ```
> > [main ef7b51c] 2nd commit
> >  1 file changed, 2 insertions(+)
> > ```
> 
> 手元のログは以下のようになっています：
> 
> ```bash
> git log --oneline  
> ```
> > ```
> > ef7b51c (HEAD -> main) 2nd commit
> > 81ccbe7 (origin/main) Update test.txt
> > de9a8eb 1st commit
> > ```
> 
> `origin/main` より `HEAD` が進んでいることに注目してください。さて、この状態でpushすると：
> 
> ```bash
> git push
> ```
> > ```
> > Enter passphrase for key '私のGitHubの鍵のパス': 
> > To github.com:AkinoriTanaka-phys/test.git
> >  ! [rejected]        main -> main (non-fast-forward)
> > error: failed to push some refs to 'github.com:AkinoriTanaka-phys/test.git'
> > hint: Updates were rejected because the tip of your current branch is behind
> > hint: its remote counterpart. Integrate the remote changes (e.g.
> > hint: 'git pull ...') before pushing again.
> > hint: See the 'Note about fast-forwards' in 'git push --help' for details.
> > ```
> 
> となって、拒否されます。メッセージを読むと、pushする前にpullせよ、と言っています。そこで pull しようとします：
> 
> ```bash
> git pull
> ```
> > ```
> > Enter passphrase for key '私のGitHubの鍵のパス': 
> > remote: Enumerating objects: 5, done.
> > remote: Counting objects: 100% (5/5), done.
> > remote: Compressing objects: 100% (2/2), done.
> > remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)
> > Unpacking objects: 100% (3/3), 959 bytes | 191.00 KiB/s, done.
> > From github.com:AkinoriTanaka-phys/test
> >    81ccbe7..dad5373  main       -> origin/main
> > hint: You have divergent branches and need to specify how to reconcile them.
> > hint: You can do so by running one of the following commands sometime before
> > hint: your next pull:
> > hint: 
> > hint:   git config pull.rebase false  # merge
> > hint:   git config pull.rebase true   # rebase
> > hint:   git config pull.ff only       # fast-forward only
> > hint: 
> > hint: You can replace "git config" with "git config --global" to set a default
> > hint: preference for all repositories. You can also pass --rebase, --no-rebase,
> > hint: or --ff-only on the command line to override the configured default per
> > hint: invocation.
> > fatal: Need to specify how to reconcile divergent branches.
> > ```
> 
> こんな感じで何か起こったっぽいメッセージが出ます。ホストと食い違った場合の処理をconfigで定めなければいけないようです。とりあえずメッセージの一番上の選択肢にすることにします：
> 
> ```bash
> git config pull.rebase false
> git pull
> ```
> > ```
> > Enter passphrase for key '私のGitHubの鍵のパス': 
> > Auto-merging test.txt
> > CONFLICT (content): Merge conflict in test.txt
> > Automatic merge failed; fix conflicts and then commit the result.
> > ```
> 
> さて今度はマージでコンフリクトが起きました。対象ファイルを見ると
> 
> ```bash
> cat test.txt
> ```
> > ```
> > <<<<<<< HEAD
> > From local, hello!
> > =======
> > From browser, hello!
> > >>>>>>> dad537383e36bd4dd8531e05871be752bb7883a2
> > 
> > this is test!
> > Added from online!!
> > ```
> こんなふうになっています。これはブランチ間でマージの際の競合解決と同じです。適当に編集してコミットすればマージ完了し、それをコミットすれば良いです。例えば
> 
> ```bash
> cat test.txt
> ```
> > ```
> > From local and browser, hello!
> > 
> > this is test!
> > Added from online!!
> > ```
> 
> こんなふうにしてみました。これでコミットし、プッシュすると：
> 
> ```bash
> git add test.txt; git commit -m "3rd commit"
> git push
> ```
> > ```
> > [main 9f32961] 3rd commit
> > Enter passphrase for key '私のGitHubの鍵のパス': 
> > Enumerating objects: 10, done.
> > Counting objects: 100% (10/10), done.
> > Delta compression using up to 8 threads
> > Compressing objects: 100% (4/4), done.
> > Writing objects: 100% (6/6), 595 bytes | 595.00 KiB/s, done.
> > Total 6 (delta 0), reused 0 (delta 0), pack-reused 0
> > To github.com:AkinoriTanaka-phys/test.git
> >    dad5373..9f32961  main -> main
> > ```
> 
> この状態でlogを見てみると
> 
> ```bash
> git log --oneline --graph --decorate --all 
> ```
> > ```
> > *   9f32961 (HEAD -> main, origin/main) 3rd commit
> > |\  
> > | * dad5373 Update test.txt
> > * | ef7b51c 2nd commit
> > |/  
> > * 81ccbe7 Update test.txt
> > * de9a8eb 1st commit
> > ```
> このようになっています。枝分かれしている方（`Update test.txt`）がブラウザからのコミットです。ブラウザを見に行ってみると、確かに競合解決後のファイルになっていることがわかります。
> 
> </details>


## コラム1： お作法いろいろ

共同作業を行う際には色々なお作法（マナー）がつきものですが、`git` の利用に関しても、コマンドの使用法とは別に、その使用に関するメンタル的なお作法があります。ここでは代表的なものを紹介します。

1. `main` ブランチは直接編集しない
    - これは共同作業の際に使われることのあるルールで、`main` ブランチは安定版として（例えばプログラムなどであれば「バグなく動くバージョン」の履歴だけ残すように）運用するというものです。
    - 具体的には、各ユーザーは編集する際「なるべくブランチを切る」ということです。そしてブランチを成長させてゆき、安定版（`main`）に結合してもよいと判断したタイミングで、そちらに `git merge` するということです。
    - 場合によっては `git merge` する係が決まっていて、その人に「このブランチの編集を採用してください」と依頼し、内容をレビューした上でマージしてもらいます。これを **プルリクエスト**と言います。
        > なお、すでに本文で説明した通り、GitHub ではブラウザ上でプルリクエストの作成やマージを行うための UI が提供されています。実際にはその UI を使った操作を指して「プルリクエスト」と呼ぶこともありますが、考え方としてはここで説明した内容をイメージしてもらえれば十分だと思います。
    - とは言っても、最初は難しい気もするので、自分で使う分には慣れてきたらで良いと思います。
2. コミット履歴の過去改変はしない
    - このノートでは解説しませんでしたが、コミット履歴を編集することもできます。複数名で共同作業している場合、誰かが「過去改変されたコミット履歴を無理やり `git push` する」ことも可能です。
    - すると、他のユーザーが `git pull` しようとする際にトラブルが起こります。具体的には、リモートの履歴とローカルの履歴が食い違い、同じ変更が二重に適用されたように見えたり、意図しないコンフリクトが発生する原因になります。
    - ですので、**このお作法はなるべく守るようにしてください**。イメージ的には一度コミットしたものは、変更を加える場合でもコミット履歴を書き換えずに、新たなコミットで対応するということです。
> [!WARNING]
> コミット履歴の過去改変をGitHubなどのホスティングサービス上のリポジトリに行うと、表面上は origin/ブランチ名 の履歴が変更されたように見えるものの、元のコミット履歴も（追跡できないだけで）残っておりIDさえわかれば復元できるそうです。**GitHubなどのホスティングサーバー上から完全には消えないと考えた方が良さそうです**。万が一、消したい履歴ができた場合はこれを読むといいかもしれません：https://docs.github.com/ja/authentication/keeping-your-account-and-data-secure/removing-sensitive-data-from-a-repository
3. コミット単位を工夫する
    - 後々、バージョンを戻す際に「このコミットに戻ってブランチを切る」とかするわけなので、それぞれのコミットに意味がついていると戻す際に便利です。
    - なおサイズの大きいファイルはコミット（可能ですが）非推奨です。例えばtex文書などであればコンパイルで発生するファイルは、どうせコンパイル成功すれば手に入れられるため、コミット履歴に含めないなどです。

## コラム2：コマンドライン以外での使用

`git` コマンドを覚えなくても、このノートで紹介した典型的なワークフロー（コミットやブランチ、マージ、プルなど）を理解しておけば、コマンドラインからではなくアプリを使う方が便利かもしれません。私は昔は

- SourceTree: https://www.sourcetreeapp.com/

を使っていましたが、現在はエディタと結合された `git` 環境が便利だと感じ、

- VScode: https://code.visualstudio.com/

のなかで `git` を使っています。これらのアプリとコマンドラインはもちろん併用できます。
